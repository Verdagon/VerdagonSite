---
title: What Vale Taught Me About a Memory Safe C++
subtitle: And why we love it!
realm: blog
date: May X, 2023
path: blog/vale-memory-safe-cpp
layout: annotated
author: Evan Ovadia
sponsor: me
namespace: c-blog m-annotated
---

! This article is still in early access for friends and sponsors, thank you so much to everyone who has helped Vale come this far!


Even though I spend most of my time writing in Vale, Rust, and Scala, I am a C++ programmer at heart.


It has a combination of speed and flexibility that no other mainstream language has really nailed.


This combination even inspired me make [Vale](https://vale.dev/), to see if we could make a high-performance language that has memory safety, but also still has that C++ flexibility and spirit. And in that quest, I've discovered some *surprising truths.*


The world largely believes that reference counting, tracing garbage collection, and borrow checking are the only ways to make code memory safe.


I've found eleven more approaches, and I'm about to show you *how they can make C++ memory-safe.* [# One day I'd love to write a series called The Memory Safety Grimoire where I talk about all of these.] [# For a sneak peek, here they are: generational references, vale references, constraint references, regions, arenas, mutable value semantics, interaction nets, basil memory stacks, CHERI capabilities, neverfree, MMM++, SPARK, and linear types. More than eleven really, but there is some overlap.]


These techniques are great tools for the toolbox, to use where they make sense. [# As is the C++ way!] My goal here isn't to propose some sort of grand new direction for C++, it's just to enlighten. [# There is no silver bullet, and these techniques have their tradeoffs, but I hope this will show C++'s potential and inspire others to take these ideas and run with them.]


Buckle up, because we're about to design a whole new memory safety model for C++! [# It won't be the same as Vale's, which makes this a much more fun experiment. If I had to come up with a name for this C++ memory safety approach, I might call it the "affine-aliasing model" or something.]



# unique_ptr

C++11's `unique_ptr` is a class that tracks who has sole responsibility for destroying an object.

This one little class singlehandedly brought the concepts of single ownership and move semantics into the mainstream, and it will serve as the starting point for our memory safety.


Our first principle is that *dereferencing a unique_ptr is safe*, as long as we follow these two rules:

*Rule 1:* Always initialize a `unique_ptr` to contain something. [# If you want a nullable unique_ptr, consider wrapping it in an `optional`.]

*Rule 2:* Don't use a `unique_ptr` local variable after moving from it. [# Linters enforce this for local variables, but not for fields. We'll have another rule to address that below.]


Some linters even enforce that second one already.


So far, this is pretty obvious. A lot of us follow these rules already in our codebases.

The next part will be obvious too, and after that things get more interesting.


# Stack objects are safe

<<<<
Our next principle is that, of course, accessing the fields of an object on the stack is safe too.


That _doesn't_ include making a pointer to a stack-allocated object and then dereferencing. [# Technically, the compiler might produce a temporary reference when we say the name of a variable. That's fine, as long as we don't make references or pointers directly.] Only accessing a field _directly_ is safe.
////
```cpp
struct Ship { int fuel; };
void main() {
  Ship ship{ 42 };
  // Safe to access ship's fields.
  cout << ship.fuel << endl;
}
```
>>>>



Now that the more obvious principles are out of the way, let's get to the interesting stuff.



# Move-destructuring

This next rule helps keep us from risking accessing any fields that have been invalidated.


*Rule 3:* We can only move out of a field if we swap something into its place or destroy the containing struct.


By destroying the containing struct, we remove the opportunity to ever use that (invalid) field.


<<<<
In this example, a `Ship` contains a `unique_ptr<Engine>`.


We remove the `unique_ptr<Engine>` from the containing `Ship`, and then destroy the `Ship`.


This is such a common operation that other single-ownership based languages have syntax for destroying a struct and extracting its members.

Vale's *move-destructuring* does this, e.g. `[engine] = ship;` but we can do it manually for C++. [# Ironically, we can't do it at all in Rust, because Rust doesn't let us move out of fields. It's needed much less in Rust though.]
////

```cpp
struct Engine {
  int fuel;
  Engine(int fuel_) : fuel(fuel_) {}
};

struct Ship {
  unique_ptr<Engine> engine;
  Ship(unique_ptr<Engine> engine_) :
      engine(move(engine_)) {}
};

void main() {
  auto ship =
      make_unique<Ship>(
          make_unique<Engine>(42));

  auto engine = move(ship->engine);
  ship = nullptr;
  // Can't use ship again, per rule 2

  // ... do something with Engine
}
```
>>>>


The above example is fairly simple, but it could get a bit more difficult if we don't have ownership of the containing struct conveniently nearby.

We may need to refactor and pipe ownership of the containing struct all the way to here. Further below, we'll talk about this drawback and ways to address it.


# Resizable Collections

*Rule 4:* Only use std::array and resizable collections, don't use raw arrays directly.

This is because raw arrays temporarily risk some unsafety when we first make them and when we're destroying them.


There are a lot of ways we can relax these restrictions.


For example, we could have a runtime-sized array where we construct it with a size `N` and a closure, and the library (or language) will invoke that closure `N` times, filling the array's elements with the closure calls' results.


Or we can make something halfway between `std::array` and `std::vector`, which doesn't resize past its initial capacity, but still has `size` and `capacity` fields and methods like `push`, `pop` etc.


Vale's arrays are like that, and they're used to implement the standard library's array list, hash map, etc.


Bounds-checked array slices could also make life easier, so that functions could take in an arbitrary range of elements.


# Avoid raw pointers and references [# We'll still be using them indirectly of course; dereferencing a `unique_ptr` produces a temporary reference. But we won't be using raw pointers or references directly.]

I know, that sounds impossible _and_ ridiculous.


"How in the world would we get anything done without raw pointers and references?" I can hear you say.

But I assure you, it is possible. And don't worry, we'll be *adding aliasing back in later*.


But for now, here are some rules to understand how to make programs without aliasing.


*Rule 5:* When you want to take a pointer or a reference as a parameter, instead take (and return) a unique_ptr or a stack object.


<<<<
Instead of taking a `Ship` pointer like this:

```cpp
struct Ship { int fuel; };
void print(Ship* ship) {
  cout << ship.fuel << endl;
}
```
////
...`print` would take (and return) it:

```cpp
struct Ship { int fuel; };
Ship print(Ship ship) {
  cout << ship.fuel << endl;
  return ship;
}
```
>>>>


*Rule 6:* When you want a raw pointer as a field, use an index or an ID instead.


Instead of a `Ship` having a `Port*` like this...

```cpp
struct Port { string name; };
struct Ship { Port* port; };

Ship print(Ship ship) {
  cout << ship.port->name << endl;
  return ship;
}
```

...we would do something conceptually similar to this, where `print` uses the `portId` to read the `Port` from a map.

```cpp
struct Port { string name; };
struct Ship { int portId; };

Ship print(unordered_map<Port>* ports, Ship ship) {
  cout << ports[ship.portId].name << endl;
  return ship;
}
```



Of course, we'll need to change that pointer parameter according to rule 5. We'll instead take and return the vector directly:

```cpp
struct Port { string name; };
struct Ship { int portId; };

tuple<unordered_map<Port>, Ship> print(
    unordered_map<Port> ports,
    Ship ship) {
  cout << ports[ship.portId].name << endl;
  return make_tuple(ports, ship);
}
```



That's pretty verbose! We'll see some ways to make it less verbose further below.


These two rules may seem familiar to those who have used Rust; taking and returning a `Ship` is semantically equivalent to taking an `&mut Ship`, and the borrow checker often makes reference struct fields into indices/IDs as well.

However, we'll be deviating from Rust's direction pretty sharply.



# The approach so far

The foundational rules above have achieved their goal: *we now have a memory-safe subset of C++.*


But let's take a step back and recognize its drawbacks, and see how we might address them.


Besides being verbose, there are also some architectural consequences:


*Drawback 1:* Since Rule 5 requires us to change our function signature (by borrowing the `vector<Ship>`), and all of our callers' callers' callers, this technique has become a *viral leaky abstraction*.


*Drawback 2:* Rule 6 puts a lot of our objects into collections, making our program almost similar to a relational database.


*Drawback 3:* Since we can't use raw pointers and references, we effectively cut ourselves off from mutable aliasing. This is a problem, because it means we can't use fast approaches like intrusive data structures and graphs, and we can't use useful patterns like observers, back-references, dependency references, callbacks, delegates and many forms of RAII.


These are familiar to Rust users; `&mut` is semantically equivalent to everything we're doing here and has the same drawbacks. This is the downside of eliminating mutable aliasing. Luckily, Rust partially resolves them with `Rc` and `RefCell`, for those willing to use them.


So should we do something like `shared_ptr<optional<T>>` then, or are there any other options?


There are! Let's talk about *generational references*, *vale references*, and *constraint references*.


# Generational References

A *generational reference* is where each object has a current "generation number".

 * When we want to point to an object, we remember its address and its generation.
 * When we free an object, we increment its generation number.
 * To get access to an object, we first assert ("generation check") that the current generation number matches the remembered generation number.

It's equivalent to the generational indices method, but applied to a heap.


To learn more, check out [this article](https://verdagon.dev/blog/generational-references) which talks about how we added them to Vale (though, the next section talks about an improved version).


In Vale the entire language uses generational references, which simplifies some things. For C++, we'll need to add something extra.


Above, when I mentioned we can "get access to an object", I didn't actually mean dereferencing. We'll need an extra step of "checking out" the contents to take ownership of it from the original owner. Before the end of the scope, we're required to put something back into that spot. [# This is basically the same thing as Rust's `RefCell`.] [# We might also need `enable_genref_from_this`, for the same reasons `enable_shared_from_this` exists.]


<<<<
Using a generational reference would look something like this snippet. [# Let me know if you want some example code for this and I can dig it up from the Vale histories.]


An object lives inside a `gowned` wrapper.


We use its `ref()` method to make a `gref` to it. [# We can also just copy an existing `gref`.]


We can `open` a `gref`, which does a generation check and gives us something we can dereference.
////
```cpp
// Makes an object
gowned<Ship> ship =
    make_gowned<Ship>(42);

// Makes a generational reference to it
gref<Ship> shipRef = ship.ref();

// Does a generation check
auto shipHandle = shipRef.open();

// Prints 42
cout << shipHandle->fuel << endl;
```
>>>>


There's a couple downsides to this approach.

 * It forces objects onto the heap, like `Rc` and `shared_ptr`.
 * It uses an allocator which segregates by size class and never releases memory back to the OS, to ensure that nobody messes with the generation number of the object and there is no reusing of numbers.

Both of these are addressed by the next approach.


# Vale References

Previously known as "generational references V2", a vale reference is a generational reference with one adjustment: it uses a *pseudo-random generation number* for every object.


It's better in that it doesn't use a special allocator, and objects can live on the stack and inside other objects.


The drawback, of course, is that the generation check can have a false negative in theory, depending on the width of the generation number.


Usage would be the same as the above generational references, and a simple C++ implementation would look roughly like the below code (also available [here](https://github.com/Verdagon/ValeanCpp/blob/main/vref.h)).


```cpp
extern size_t vrefNextKey;

template<typename T>
class vref {
public:
  vref(vowned<T>* own_) :
    own(own_),
    rememberedKey(own_->currentKey) {}
  ~vref() {}

  vref_guard<T> open() {
    return vref_guard<T>(own, rememberedKey);
  }

private:
  size_t rememberedKey;
  vowned<T>* own;
};

template<typename T>
class vref_guard {
public:
  vref_guard(vowned<T>* own_, size_t rememberedKey) :
      own(own_) {
    assert(rememberedKey == own->currentKey);
    assert(own->present);
    own->present = false;
  }
  ~vref_guard() {
    own->present = true;
  }

  T* operator->() { return &own->contents; }
  const T* operator->() const { return &own->contents; }

private:
  vowned<T>* own;
};

template<typename T>
class vowned {
public:
  vowned(T contents_) :
      present(true),
      currentKey(vrefNextKey++),
      contents(std::move(contents_)) {}
  ~vowned() {
    assert(present);
  }

  vref<T> ref() {
    return vref<T>(this);
  }

private:
  friend class vref<T>;
  friend class vref_guard<T>;

  bool present : 1;
  size_t currentKey : 63;
  T contents;
};

template<typename T, typename... P>
vowned<T> make_vowned(P&&... params) {
  return vowned<T>(T(std::forward<P>(params)...));
}
```



This simple implementation uses:

 * A monotonically incrementing `vrefNextKey` integer as its pseudo-random number generator.
 * A 63 bit generation (so we can use 1 bit for the `present` boolean), making the odds of a false negative about 1/2^63.


If you've ever heard of Arm's [memory tagging](https://source.android.com/docs/security/test/memory-safety/arm-mte), this is like that but with a wider tag.


Depending on the size of your generation/tag, you can make this robust enough to detect bugs in development and testing (1/16 like memory tagging) or robust enough for use in security purposes.


This approach has one additional benefit. For domains where its appropriate, it can be turned completely off for production code, and it would be as efficient as normal C++. This can be a pretty stellar tradeoff for single player games, compilers, or sandboxed situations like webassembly modules or apps.


There are some other downsides in theory:

 * If we access memory already freed to the operating system, instead of an assertion failure we'd get a segmentation fault.
    * If we're on a devices with no segmentation faults nor virtual memory, this might not be a good approach. [# In those cases, a Vale program might balance a linear style with immutable region borrowing for aliasing.]
 * We can contrive some cases where a sufficiently intelligent optimizer can detect that we're accessing already-destroyed objects, and consider it undefined behavior.


Still, for the vast majority of use cases, this is a great tradeoff.


# Constraint References

Another option is to use something called a *constraint reference*, which allows for memory-safe mutable aliasing, while allowing objects to live on the stack or directly inside another object.


Basically, we:

 * Put the reference count directly inside the object.
 * We refer to the object with a `constraint_ref` which works similarly to a `shared_ptr`.
 * When the object goes out of scope, it asserts that the count is zero, that no objects point to it any more.


A simplified implementation would look something like this (also available [here](https://github.com/Verdagon/ValeanCpp/blob/main/cref.h)):

```cpp
template<typename T>
class cref {
public:
  cref(cowned<T>* own_) : own(own_) { own->refCount++; }
  ~cref() { own->refCount--; }
  cref_guard<T> open() { return cref_guard<T>(own); }

private:
  cowned<T>* own;
};

template<typename T>
class cref_guard {
public:
  cref_guard(cowned<T>* own_) :
      own(own_) {
    assert(own->present);
    own->present = false;
  }
  ~cref_guard() {
    own->present = true;
  }
  T* operator->() { return &own->contents; }
  const T* operator->() const { return &own->contents; }

private:
  cowned<T>* own;
};

template<typename T>
class cowned {
public:
  cowned(T contents_) :
      present(true),
      refCount(0),
      contents(move(contents_)) {}
  ~cowned() {
  	assert(present);
  	assert(refCount == 0);
  }

  cref<T> ref() {
  	return cref<T>(this);
  }

private:
  friend class cref<T>;
  friend class cref_guard<T>;

  bool present : 1;
  size_t refCount : 63;
  T contents;
};
```


It works similarly to a foreign key constraint in SQL, hence the name constraint reference. [# If you want to read more about constraint references, check out [The Next Steps for Single Ownership and RAII](https://verdagon.dev/blog/raii-next-steps). The ones described in there are slightly different in that they don't require "checking out" the object.]


This was also explored by Adam Dingle and David Bacon in their paper [Ownership You Can Count On:
A Hybrid Approach to Safe Explicit Memory Management](https://web.archive.org/web/20220111001720/https://researcher.watson.ibm.com/researcher/files/us-bacon/Dingle07Ownership.pdf), who made an entire C# variant using this. This is also one of the mechanisms behind the language [Inko](https://inko-lang.org/), as described in the article [Friendship ended with the garbage collector](https://yorickpeterse.com/articles/friendship-ended-with-the-garbage-collector/).


To get the object from the `constraint_ref`, we "check out" the contents and take ownership of it from the original owner. Before the end of the scope, we're required to put something back into that spot, via a `constraint_guard` object. [# This is basically the same thing as Rust's `RefCell`.] [# We might also need `enable_constraint_from_this`, for the same reasons `enable_shared_from_this` exists.]


Similar to vale references, this can be turned off in production and be as efficient as normal C++ code.


The obvious downside, of course, is that if you violate the constraint, your entire program halts. This makes it unusable in a lot of cases.


# Whether to add shared ownership

Before we add something like Rust's `Rc<RefCell<T>>`, let's ask the question: how much do we really need it?


This is a familiar question to anyone who has used Rust. One of my favorite things to do in Rust is to see how far we can get by just using the borrow checker, and not using `Rc<RefCell<T>>`.


  However, such a style can have the three drawbacks we mentioned above:

 * When we need a `&mut`, we're required to change the signature of the containing function, its callers, its callers' callers and so on, becoming a *viral leaky abstraction*.
 * When we need to mutate something, we often need to put a lot of our objects into collections, making our program almost similar to a relational database.
 * Since we don't have mutable aliasing, we can't use fast approaches like [intrusive data structures](https://lwn.net/Articles/907876/), [observers](https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/) and [graphs](https://news.ycombinator.com/item?id=24996001), and we can't use useful patterns like [observers](https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/), [back-references](https://users.rust-lang.org/t/back-reference-to-the-parent-struct/7413/2), [dependency references](https://en.wikipedia.org/wiki/Dependency_injection), [callbacks](https://news.ycombinator.com/item?id=12029238), [delegates](https://medium.com/@nimjea/delegation-pattern-in-swift-4-2-f6aca61f4bf5) and many forms of RAII [# RAII is about automatically affecting the world outside our object. To affect the outside world, the borrow checker often requires us to take a `&mut` parameter or return a value, but we can't change `drop`'s signature. To see this in action, try to make a handle that automatically removes something from a central collection. Under the hood we usually use `unsafe` mechanisms, including FFI.].


In my opinion, this shows the wisdom of the Rust language designers in adding `Rc` and `RefCell` to the standard library.


So does all this mean we should add something like `Rc<RefCell<T>>`? Perhaps.


Some considerations about adding shared ownership:

 * It would force objects onto the heap.
 * It would interfere with RAII; logic bugs might cause destructors to fire later than we intend.
 * We already have `gref`, `vref`, and `cref` above, which all add mutable aliasing, so it's unclear how much benefit we'd get.


We also have some techniques available to us that borrow checking does not. For example, in cases where there would only be two people with references to an object, we could make a bidirectional optional reference, where if we destroy one side we null out the other. [# I even made a thread-safe version of these with two mutexes, when I was working on Earth.]


These are all reasons we don't have any sort of shared ownership in Vale quite yet.


However, we likely will someday, because we can contrive a few situations where it might be beneficial. For example, we might want a `FileCache` object that counted how many classes had a file open for reading. If anyone knows of an alternative to that, let me know!


So, all that said, let's talk about how we might add shared ownership in!


# Shared Ownership

It would likely take the form of a `shared_ptr<optional<T>>`.


<<<<
We would "check out" the value by using the `.value()` method.


After we're done using it, we would put the object back into the `shared_ptr`'s `optional`.
////

```cpp
// Makes an object
auto ship =
    make_shared<optional<Ship>>(
        make_optional<Ship>(42));

// Makes another reference to it
auto shipRef = ship;

// Check it out.
// This value() asserts it's present
auto ship = shipRef->value()

// Prints 42
cout << ship.fuel << endl;

// Put it back
*shipRef = make_optional<Ship>(ship);
```
>>>>


We could also make a "handle" object that uses RAII to ensure we put that `ship` back into the shared_ptr, similar to what we did with `gref`/`vref`/`cref`.


# Simple Borrowing

The main reason C++ can't do borrow checking like Rust is because it doesn't have lifetimes and annotations.


Is there perhaps a simple form of borrow checking it can do, which doesn't require those?


Something like `&mut` wouldn't be hard. We just add pointers back in, with the rules that we don't access the original object while it exists, don't return them, don't store them in structs/arrays, and don't alias them. [# [Val](https://www.val-lang.dev/) does this with its [mutable value semantics](http://www.jot.fm/issues/issue_2022_02/article2.pdf).]


I believe we can also add some form of immutable shared references too if we replace that last rule with "don't modify anything through them". [# I think this is what [Austral](https://austral-lang.org/) does with its [linear type checker](https://borretti.me/article/how-australs-linear-type-checker-works), but I could be wrong.]


In other words, as long as we aren't returning or storing references, I think we don't really need lifetimes or annotations.


# How might we make this happen?

I'm not sure! That's a question involving committees, standards, backwards compatibility, and other big topics. And alas, Vale is keeping my hands full.


But perhaps all of this has inspired someone out there to investigate these possibilities.


I'd perhaps recommend them to start with some sort of linter. These are all pretty simple locally-verifiable rules. Perhaps it would only be enabled for certain types, or any types with a certain suffix.


We can even imagine a future where there's some sort of "C++ safe mode" where the linter is enabled by default, and then we break out of it with `unsafe` blocks.


Or perhaps a project like [Carbon](https://github.com/carbon-language/carbon-lang) or [CppFront](https://github.com/hsutter/cppfront) could have some sort of support for these approaches. [# To Herb and/or Chandler, let me know you ever want to talk memory safety over some cider!]


# Conclusion

Thats it! I hope you enjoyed this whirlwind tour of the various ways we can add memory safety to C++.


If you liked this article, please consider [sponsoring Vale on GitHub](https://github.com/sponsors/ValeLang)! Your sponsorships make it so I can keep writing articles like this.


If you have any questions, message me on [twitter](https://twitter.com/verdagon), the [discord server](https://discord.gg/SNB8yGH), or [subreddit](https://reddit.com/r/vale).


Until next time!

- Evan Ovadia

