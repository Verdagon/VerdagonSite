---
title: Making C++ Memory-Safe Without Borrow Checking, Reference Counting, or Tracing Garbage Collection
subtitle: Glory to the grimoire!
realm: blog
date: May X, 2023
path: blog/vale-memory-safe-cpp
layout: annotated
author: Evan Ovadia
sponsor: me
namespace: c-blog m-annotated
---

! This article is still in early access for friends and sponsors, thank you so much to everyone who has helped Vale come this far!


Adding memory safety to C++ is a very difficult problem, to say the least.


I've spent most of the last decade exploring this area to design [Vale](https://vale.dev/)'s memory safety, and I've luckily discovered some *surprising things* which might make it a bit easier.


The world largely believes that the only ways to make code memory safe are through reference counting, tracing garbage collection, or borrow checking.


It turns out, there's at least *eleven more methods,* with more being discovered all the time. [# For a sneak peek, here they are: generational references, random generational references, constraint references, regions, arenas, mutable value semantics, interaction nets, basil memory stacks, CHERI capabilities, neverfree, MMM++, SPARK, and linear types. More than eleven really, but there is some overlap.] [# One day, I want to write about all these methods, and call the book the "Memory Safety Grimoire". That'd be pretty sweet!]


Someone asked me recently, can we use these techniques to add some memory safety to C++?


We can! It's something I've been thinking about for a while, and it's about time I write it all down.


# The Challenges

We're going to do this without borrow checking, reference counting, or tracing garbage collection.


Not because they're bad, of course. They have some great benefits:

 * Tracing GC is the simplest model for the user, and helps with time management and development velocity, two very important aspects of software engineering.
 * Reference counting is simple and allows for more predictable destruction of objects.
 * Borrow checking is _very_ fast, and helps avoid data races.


However, they each have their drawbacks too:

 * Tracing GC can have some unpredictable pauses sometimes, while it stops the world to figure out which objects are still alive.
 * Reference counting is often the slowest approach (though I think that will change in the next decade [#rcfast]).
 * Borrow checking is incompatible with some useful patterns and optimizations (described later on), and its strict and infectious nature can have trouble coexisting with non-borrow-checked code.


They also have their pragmatic limitations:

 * Making tracing GC work well with C++ would be tricky, since the GC would need to find everywhere the normal C++ objects have references to garbage-collection-managed objects.
 * Reference counting is pretty doable actually, as shown by `shared_ptr`.
 * Borrow checking has a high complexity cost in the form of lifetimes, annotations, etc. and C++ is a very complex language already.


I'm about to describe a different approach, with its own tradeoffs. It's no silver bullet, and I wouldn't claim that it's objectively the best way to do things. It's merely an interesting possibility.


These techniques are all possible, as far as I know. Between Vale, Val, Austral, Rust, Inko, and a few others, these techniques have all been implemented one place or another. I think they'll be compatible with C++ and compose well with each other, but I could be wrong, and there could also be some obstacles in the way.


And as a bonus, they're not only possible, they can probably be achieved with only static analysis, maybe even just a well-crafted linter. [# If anyone wants to actually attempt this, let me know!]


<slice>
#rcfast: I think a language will come along that blends reference counting with [regions](/blog/zero-cost-borrowing-regions-overview) and linear or unique types. That would eliminate the vast majority of reference counting operations, which might make RC competitive again.
</slice>


# The techniques

We're going to blend *five main ingredients* to achieve our memory safety:

 * Borrowless affine style, via `unique_ptr` and owned values (from Vale, Val, and Austral)
 * Constraint references (from GelLLVM, Inko, and Vale)
 * Generational references and random generational references (from Vale)
 * Unique borrowing (from Austral, Val, and Rust)
 * Simple immutable borrowing (from Austral)


Each one is sufficient on its own actually, but I'll explain why it's good to have this particular blend's flexibility.


# Borrowless Affine Style [# DRAFT: I'm thinking this entire aspect should perhaps be framed differently, or perhaps be reordered to after constraint refs / vale refs / gen refs. It seems like the reader is getting pretty and taking a lot of leaps of faith before we get to the payoff]

This technique blew my mind [pretty spectacularly](/blog/linear-types-borrowing), especially when I realized that it was already hidden beneath the surface in languages like Vale, Austral, Val, and Rust.


This technique shows that we don't need tracing GC, reference counting, borrow checking, or anything for memory safety. We just need to change the way we move data around.


Let's start by adding some *arbitrary-sounding rules*, and then we'll tie them all together into something that makes sense.


## unique_ptr

C++11's `unique_ptr` is a class that tracks who has sole responsibility for destroying an object.

This one little class singlehandedly brought the concepts of single ownership and move semantics into the mainstream, and it will serve as the starting point for our memory safety.


Our first principle is that *dereferencing a unique_ptr is safe*, as long as we follow these two rules:

*Rule 1:* Always initialize a `unique_ptr` to contain something. [# If you want a nullable unique_ptr, consider wrapping it in an `optional`.]

*Rule 2:* Don't use a `unique_ptr` local variable after moving from it. [# Linters enforce this for local variables, but not for fields. We'll have another rule to address that below.]


Some linters even enforce that second one already.


So far, this is pretty obvious. A lot of us follow these rules already in our codebases.

The next part will be obvious too, and after that things get more interesting.


## Stack objects are safe too

<<<<
Our next principle is that, of course, accessing the fields of an object on the stack is safe too.


That _doesn't_ include making a pointer to a stack-allocated object and then dereferencing. [# Technically, the compiler might produce a temporary reference when we say the name of a variable. That's fine, as long as we don't make references or pointers directly.] Only accessing a field _directly_ is safe.
////
```cpp
struct Ship { int fuel; };
void main() {
  Ship ship{ 42 };
  // Safe to access ship's fields.
  cout << ship.fuel << endl;
}
```
>>>>



Now that the more obvious principles are out of the way, let's get to the interesting stuff.



## Move-destructuring

This next rule helps keep us from risking accessing any fields that have been invalidated.


*Rule 3:* We can only move out of a field if we swap something into its place or destroy the containing struct.


By destroying the containing struct, we remove the opportunity to ever use that (invalid) field.


<<<<
In this example, a `Ship` contains a `unique_ptr<Engine>`.


We remove the `unique_ptr<Engine>` from the containing `Ship`, and then destroy the `Ship`.
////
```cpp
struct Engine {
  int fuel;
  Engine(int fuel_) : fuel(fuel_) {}
};

struct Ship {
  unique_ptr<Engine> engine;
  Ship(unique_ptr<Engine> engine_) :
      engine(move(engine_)) {}
};

void main() {
  auto ship =
      make_unique<Ship>(
          make_unique<Engine>(42));

  auto engine = move(ship->engine);
  ship = nullptr;
  // Can't use ship again, per rule 2

  // ... do something with Engine
}
```
\\\\
This is such a common operation that other single-ownership based languages have syntax for destroying a struct and extracting its members.

Vale's *move-destructuring* does this, e.g. `[engine] = ship;` but we can do it manually for C++. [# Ironically, we can't do it at all in Rust, because Rust doesn't let us move out of fields. It's needed much less in Rust though.]
>>>>


The above example is fairly simple, but it could get a bit more difficult if we don't have ownership of the containing struct conveniently nearby.

We may need to refactor and pipe ownership of the containing struct all the way to here. Further below, we'll talk about this drawback and ways to address it.


## Resizable Collections

*Rule 4:* Only use std::array and resizable collections, don't use raw arrays directly.

This is because raw arrays temporarily risk some unsafety when we first make them and when we're destroying them.


There are a lot of ways we can later relax these restrictions.


For example, we could have a runtime-sized array where we construct it with a size `N` and a closure, and the library (or language) will invoke that closure `N` times, filling the array's elements with the closure calls' results.


Or we can make something halfway between `std::array` and `std::vector`, which doesn't resize past its initial capacity, but still has `size` and `capacity` fields and methods like `push`, `pop` etc.


Vale's arrays are like that, and they're used to implement the standard library's array list, hash map, etc.


Bounds-checked array slices could also make life easier, so that functions could take in an arbitrary range of elements.


## Avoid raw pointers and references [# We'll still be using them indirectly of course; dereferencing a `unique_ptr` produces a temporary reference. But we won't be using raw pointers or references directly.]

I know, that sounds impossible _and_ ridiculous.


"How in the world would we get anything done without raw pointers and references?" I can hear you say.

But I assure you, it is possible. And don't worry, we'll be *adding aliasing back in later*.


But for now, here are some rules to understand how to make programs without aliasing.


*Rule 5:* When you want to take a pointer or a reference as a parameter, instead take (and return) a unique_ptr or a stack object.


<<<<
Instead of taking a `Ship` pointer like this:

```cpp
struct Ship { int fuel; };
void print(Ship* ship) {
  cout << ship.fuel << endl;
}
```
////
...`print` would take (and return) it:

```cpp
struct Ship { int fuel; };
Ship print(Ship ship) {
  cout << ship.fuel << endl;
  return ship;
}
```
>>>>


*Rule 6:* When you want a raw pointer as a field, use an index or an ID instead.


Instead of a `Ship` having a `Port*` like this...

```cpp
struct Port { string name; };
struct Ship { Port* port; };

Ship print(Ship ship) {
  cout << ship.port->name << endl;
  return ship;
}
```

...we would do something conceptually similar to this, where `print` uses the `portId` to read the `Port` from a map.

```cpp
struct Port { string name; };
struct Ship { int portId; };

Ship print(unordered_map<Port>* ports, Ship ship) {
  cout << ports[ship.portId].name << endl;
  return ship;
}
```



Of course, we'll need to change that pointer parameter according to rule 5. We'll instead take and return the vector directly:

```cpp
struct Port { string name; };
struct Ship { int portId; };

tuple<unordered_map<Port>, Ship> print(
    unordered_map<Port> ports,
    Ship ship) {
  cout << ports[ship.portId].name << endl;
  return make_tuple(ports, ship);
}
```



That's pretty verbose! We'll see some ways to make it less verbose further below.


These two rules may seem familiar to those who have used Rust; taking and returning a `Ship` is semantically equivalent to taking an `&mut Ship`, and the borrow checker often makes reference struct fields into indices/IDs as well.

However, we'll be deviating from Rust's direction pretty sharply.



# The approach so far

The foundational rules above form "borrowless affine style", and they've achieved their goal: *we now have a memory-safe subset of C++.*


But let's take a step back and recognize its drawbacks, and see how we might address them by blending in some other techniques.


Besides being verbose, there are also some architectural consequences:


*Drawback 1:* Since Rule 5 requires us to change our function signature (by borrowing the `vector<Ship>`), and all of our callers' callers' callers, this technique has become a *viral leaky abstraction*.


*Drawback 2:* Rule 6 puts a lot of our objects into collections, making our program almost similar to a relational database.


*Drawback 3:* Since we can't use raw pointers and references, we effectively cut ourselves off from mutable aliasing. This is a problem, because it means we can't use fast approaches like intrusive data structures and graphs, and we can't use useful patterns like observers, back-references, dependency references, callbacks, delegates and many forms of RAII.


These are familiar to Rust users; `&mut` is semantically equivalent to everything we're doing here and has the same drawbacks. This is the downside of eliminating mutable aliasing. Luckily, Rust partially resolves them with `Rc` and `RefCell`, for those willing to use them.


So should we do something like `shared_ptr<optional<T>>` then, or are there any other options?


There are! Let's talk about *generational references*, *random generational references*, and *constraint references*.


# Generational References

A *generational reference* is where each object has a current "generation number".

 * When we want to point to an object, we remember its address and its generation.
 * When we free an object, we increment its generation number.
 * To get access to an object, we first check ("generation check") that the current generation number matches the remembered generation number. If not, we safely signal a segmentation fault.

It's equivalent to the generational indices [# DRAFT: link] method, but applied to a heap.


To learn more, check out [this article](https://verdagon.dev/blog/generational-references) which talks about how we added them to Vale (though, the next section talks about an improved version).


In Vale the entire language uses generational references, which simplifies some things. For C++, we'll need to add something extra.


Above, when I mentioned we can "get access to an object", I didn't actually mean dereferencing. We'll need an extra step of "checking out" the contents to take ownership of it from the original owner. Before the end of the scope, we're required to put something back into that spot. [# This is basically the same thing as Rust's `RefCell`.] [# We might also need `enable_genref_from_this`, for the same reasons `enable_shared_from_this` exists.]


<<<<
Using a generational reference would look something like this snippet. [# Let me know if you want some example code for this and I can dig it up from the Vale histories.]


An object lives inside a `gowned` wrapper.


We use its `ref()` method to make a `gref` to it. [# We can also just copy an existing `gref`.]


We can `open` a `gref`, which does a generation check and gives us something we can dereference.
////
```cpp
// Makes an object
gowned<Ship> ship =
    make_gowned<Ship>(42);

// Makes a generational reference to it
gref<Ship> shipRef = ship.ref();

// Does a generation check
auto shipHandle = shipRef.open();

// Prints 42
cout << shipHandle->fuel << endl;
```
>>>>


There's a couple downsides to this approach.

 * It forces objects onto the heap, like `Rc` and `shared_ptr`.
 * It uses an allocator which segregates by size class and never releases memory back to the OS, to ensure that nobody messes with the generation number of the object and there is no reusing of numbers.

Both of these are addressed by the next approach.


# Random Generational References

A random generational reference is a generational reference with one adjustment: it uses a *pseudo-random generation number* for every object, or even a global monotonically increasing integer. [# It could also be thread-local. Vale actually has an implicit `restrict uint64_t*` parameter to every function, which optimizes very nicely.]

Usage would be the same as the above generational references, and I include a sample implementation further below.


If you've ever heard of Arm's [memory tagging](https://source.android.com/docs/security/test/memory-safety/arm-mte), this is like that but with a wider tag.


*While this approach is promising, it's still ultimately unknown. I'd recommend waiting until it's studied more before using it.*


This approach has a lot of benefits:

 * The object can live on the stack, inside other objects, directly inside arrays, or even inside custom allocators.
 * We can reuse a specific spot in memory as many times as we want.
 * We're able to release memory back to the OS, in environments with virtual memory. [# This relies on the OS detecting accesses to released memory and raising segmentation faults.]


There is a theoretical downside too.

Specifically, if we ignore a failing generation check for about 10 million years [# DRAFT: use the actual number, get it from other article] and decide not to fix the problem in that time, there is a 1% chance of reusing the same generation as something that was there before. That itself isn't dangerous, but if we do use-after-free on the old object in that rare situation, it might not be detected.


Those well-versed in statistics will understand that this isn't a problem, but let's explore it a little.


The odds of a use-after-free slipping by is always `1/2^64` for a 64-bit generation.

 * The odds don't change with the number of live objects.
 * The odds don't change with the how long the program's been running. 
 * The odds don't change with the the number of objects that have lived in that particular location.
 * The odds don't change with the the number of previous generation check failures, because the first one brings down the entire process.


It also helps to keep in mind that these probabilities only apply to the error detection mechanism, not to the program itself.


One of my beta readers asks:

> "How does this compare to Rust? It seems like the probabilistic behavior wouldn't be as good."

That would be true, except that [most Rust programs](https://2020.icse-conferences.org/details/icse-2020-papers/68/Is-Rust-Used-Safely-by-Software-Developers-) use `unsafe` or have it in their dependencies, even when you don't count the stdlib.

When someone uses `unsafe` to get around the borrow checker's restrictions, even if they think really hard about `unsafe`'s more arcane interactions, bugs can remain hidden for a long time, stealthily causing undefined behavior in the `unsafe` block and in the safe code around it.

We'd similarly use random generational references to get around the restrictions of affine style, but fortunately, any use-after-frees are detected _very_ loudly as a check failure brings down the entire program. Bugs are discovered _very_ quickly, instead of causing mysterious behavior for years.

So it's better in some ways, worse than others. It's just a different approach.


Vale actually went one step further and replaced `unsafe` with a "skip-check dereference" operator to skip a generation check in release mode. The major benefit is that a compiler flag can ignore these in dependencies, so we no longer have to trust that our dependencies used unsafety well.


Even without that, when we're interoperating with a large amount of existing unsafe C++ code, this seems like an improvement in a lot of ways.


This approach is also customizable:

 * We can fall back to regular generational references with a few `#define`s.
 * We can `#define` it to normal objects and pointers, and it would be as efficient as normal C++.


There are some extra details that could complicate implementation:

 * By intentionally reading the generation number of freed memory, we are doing something the optimizer considers to be undefined behavior. We'd need to modify the optimizer or somehow communicate to it that this is fine.
 * Regular generational references safely and manually raised segmentation faults, and this mechanism will also raise segmentation faults if we access memory already returned to the OS. This means that this technique won't be appropriate for environments which don't have virtual memory.


Usage would be the same as the above generational references, and a simple C++ implementation would look roughly like the below code (also available [here](https://github.com/Verdagon/ValeanCpp/blob/main/vref.h)).


```cpp
extern size_t vrefNextKey;

template<typename T>
class vref {
public:
  vref(vowned<T>* own_) :
    own(own_),
    rememberedKey(own_->currentKey) {}
  ~vref() {}

  vref_guard<T> open() {
    return vref_guard<T>(own, rememberedKey);
  }

private:
  size_t rememberedKey;
  vowned<T>* own;
};

template<typename T>
class vref_guard {
public:
  vref_guard(vowned<T>* own_, size_t rememberedKey) :
      own(own_) {
    assert(rememberedKey == own->currentKey);
    assert(own->present);
    own->present = false;
  }
  ~vref_guard() {
    own->present = true;
  }

  T* operator->() { return &own->contents; }
  const T* operator->() const { return &own->contents; }

private:
  vowned<T>* own;
};

template<typename T>
class vowned {
public:
  vowned(T contents_) :
      present(true),
      currentKey(vrefNextKey++),
      contents(std::move(contents_)) {}
  ~vowned() {
    assert(present);
  }

  vref<T> ref() {
    return vref<T>(this);
  }

private:
  friend class vref<T>;
  friend class vref_guard<T>;

  bool present : 1;
  size_t currentKey : 63;
  T contents;
};

template<typename T, typename... P>
vowned<T> make_vowned(P&&... params) {
  return vowned<T>(T(std::forward<P>(params)...));
}
```


This simple implementation uses:

 * A monotonically incrementing `vrefNextKey` integer as its pseudo-random number generator.
 * A 63 bit generation (so we can use 1 bit for the `present` boolean), making the odds of a false negative about 1/2^63.


This approach has one additional benefit. For domains where its appropriate, it can be turned completely off for production code, and it would be as efficient as normal C++. This can be a pretty stellar tradeoff for single player games, compilers, or sandboxed situations like webassembly modules or apps.


Still, for the vast majority of use cases, this is a great tradeoff.


# Constraint References

Another option is to use something called a *constraint reference*, which allows for memory-safe mutable aliasing, while allowing objects to live on the stack or directly inside another object.


Basically, we:

 * Put the reference count directly inside the object.
 * We refer to the object with a `constraint_ref` which works similarly to a `shared_ptr`.
 * When the object goes out of scope, it asserts that the count is zero, that no objects point to it any more.


A simplified implementation would look something like this (also available [here](https://github.com/Verdagon/ValeanCpp/blob/main/cref.h)):

```cpp
template<typename T>
class cref {
public:
  cref(cowned<T>* own_) : own(own_) { own->refCount++; }
  ~cref() { own->refCount--; }
  cref_guard<T> open() { return cref_guard<T>(own); }

private:
  cowned<T>* own;
};

template<typename T>
class cref_guard {
public:
  cref_guard(cowned<T>* own_) :
      own(own_) {
    assert(own->present);
    own->present = false;
  }
  ~cref_guard() {
    own->present = true;
  }
  T* operator->() { return &own->contents; }
  const T* operator->() const { return &own->contents; }

private:
  cowned<T>* own;
};

template<typename T>
class cowned {
public:
  cowned(T contents_) :
      present(true),
      refCount(0),
      contents(move(contents_)) {}
  ~cowned() {
  	assert(present);
  	assert(refCount == 0);
  }

  cref<T> ref() {
  	return cref<T>(this);
  }

private:
  friend class cref<T>;
  friend class cref_guard<T>;

  bool present : 1;
  size_t refCount : 63;
  T contents;
};
```


It works similarly to a foreign key constraint in SQL, hence the name constraint reference. [# If you want to read more about constraint references, check out [The Next Steps for Single Ownership and RAII](https://verdagon.dev/blog/raii-next-steps). The ones described in there are slightly different in that they don't require "checking out" the object.]


This was also explored by Adam Dingle and David Bacon in their paper [Ownership You Can Count On:
A Hybrid Approach to Safe Explicit Memory Management](https://web.archive.org/web/20220111001720/https://researcher.watson.ibm.com/researcher/files/us-bacon/Dingle07Ownership.pdf), who made an entire C# variant using this. This is also one of the mechanisms behind the language [Inko](https://inko-lang.org/), as described in the article [Friendship ended with the garbage collector](https://yorickpeterse.com/articles/friendship-ended-with-the-garbage-collector/).


To get the object from the `constraint_ref`, we "check out" the contents and take ownership of it from the original owner. Before the end of the scope, we're required to put something back into that spot, via a `constraint_guard` object. [# This is basically the same thing as Rust's `RefCell`.] [# We might also need `enable_constraint_from_this`, for the same reasons `enable_shared_from_this` exists.]


Similar to collidable generational references, this can be turned off in production and be as efficient as normal C++ code.


The obvious downside, of course, is that if you violate the constraint, your entire program halts. This makes it unusable in a lot of cases.


# Whether to add shared ownership

Before we add something like Rust's `Rc<RefCell<T>>`, let's ask the question: how much do we really need it?


This is a familiar question to anyone who has used Rust. One of my favorite things to do in Rust is to see how far we can get by just using the borrow checker, and not using `Rc<RefCell<T>>`.


However, such a style can have the three drawbacks we mentioned above:

 * When we need a `&mut`, we're required to change the signature of the containing function, its callers, its callers' callers and so on, becoming a *viral leaky abstraction*.
 * When we need to mutate something, we often need to put a lot of our objects into collections, making our program almost similar to a relational database.
 * Since we don't have mutable aliasing, we can't use fast approaches like [intrusive data structures](https://lwn.net/Articles/907876/), [observers](https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/) and [graphs](https://news.ycombinator.com/item?id=24996001), and we can't use useful patterns like [observers](https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/), [back-references](https://users.rust-lang.org/t/back-reference-to-the-parent-struct/7413/2), [dependency references](https://en.wikipedia.org/wiki/Dependency_injection), [callbacks](https://news.ycombinator.com/item?id=12029238), [delegates](https://medium.com/@nimjea/delegation-pattern-in-swift-4-2-f6aca61f4bf5) and many forms of RAII [# RAII is about automatically affecting the world outside our object. To affect the outside world, the borrow checker often requires us to take a `&mut` parameter or return a value, but we can't change `drop`'s signature. To see this in action, try to make a handle that automatically removes something from a central collection. Under the hood we usually use `unsafe` mechanisms, including FFI.].


In my opinion, this shows the wisdom of the Rust language designers in adding `Rc` and `RefCell` to the standard library.


So does all this mean we should add something like `Rc<RefCell<T>>`? Perhaps.


Some considerations about adding shared ownership:

 * It would force objects onto the heap.
 * It would interfere with RAII; logic bugs might cause destructors to fire later than we intend.
 * We already have `gref`, `vref`, and `cref` above, which all add mutable aliasing, so it's unclear how much benefit we'd get.


We also have some techniques available to us that borrow checking does not. For example, in cases where there would only be two people with references to an object, we could make a bidirectional optional reference, where if we destroy one side we null out the other. [# I even made a thread-safe version of these with two mutexes, when I was working on Earth.]


These are all reasons we don't have any sort of shared ownership in Vale quite yet.


However, we likely will someday, because we can contrive a few situations where it might be beneficial. For example, we might want a `FileCache` object that counted how many classes had a file open for reading. If anyone knows of an alternative to that, let me know!


So, all that said, let's talk about how we might add shared ownership in!


# Shared Ownership

It would likely take the form of a `shared_ptr<optional<T>>`.


<<<<
We would "check out" the value by using the `.value()` method.


After we're done using it, we would put the object back into the `shared_ptr`'s `optional`.
////

```cpp
// Makes an object
auto ship =
    make_shared<optional<Ship>>(
        make_optional<Ship>(42));

// Makes another reference to it
auto shipRef = ship;

// Check it out.
// This value() asserts it's present
auto ship = shipRef->value()

// Prints 42
cout << ship.fuel << endl;

// Put it back
*shipRef = make_optional<Ship>(ship);
```
>>>>


We could also make a "handle" object that uses RAII to ensure we put that `ship` back into the shared_ptr, similar to what we did with `gref`/`vref`/`cref`.


# Simple Borrowing

The main reason C++ can't do borrow checking like Rust is because it doesn't have lifetimes and annotations.


Is there perhaps a simple form of borrow checking it can do, which doesn't require those?


Something like `&mut` wouldn't be hard. We just add pointers back in, with the rules that we don't access the original object while it exists, don't return them, don't store them in structs/arrays, and don't alias them. [# [Val](https://www.val-lang.dev/) does this with its [mutable value semantics](http://www.jot.fm/issues/issue_2022_02/article2.pdf).]


I believe we can also add some form of immutable shared references too if we replace that last rule with "don't modify anything through them". [# I think this is what [Austral](https://austral-lang.org/) does with its [linear type checker](https://borretti.me/article/how-australs-linear-type-checker-works), but I could be wrong.]


In other words, as long as we aren't returning or storing references, I think we don't really need lifetimes or annotations.


# How might we make this happen?

I'm not sure! That's a question involving committees, standards, backwards compatibility, and other big topics that won't fit in this small article.


But perhaps all of this has inspired someone out there to investigate these possibilities.


I'd perhaps recommend them to start with some sort of linter. These are all pretty simple locally-verifiable rules. Perhaps it would only be enabled for certain types, or any types with a certain suffix.


We can even imagine a future where there's some sort of "C++ safe mode" where the linter is enabled by default, and then we break out of it with `unsafe` blocks.


Or perhaps a project like [Carbon](https://github.com/carbon-language/carbon-lang) or [CppFront](https://github.com/hsutter/cppfront) could have some sort of support for these approaches. [# Herb/Chandler, let me know you ever want to talk memory safety over some cider!]


# Conclusion

Thats it! I hope you enjoyed this whirlwind tour of the various ways we can add memory safety to C++.


If you liked this article, please consider [sponsoring Vale on GitHub](https://github.com/sponsors/ValeLang)! Your sponsorships make it so I can keep writing articles like this.


If you have any questions, feel free to message me on [twitter](https://twitter.com/verdagon), the [discord server](https://discord.gg/SNB8yGH), or [subreddit](https://reddit.com/r/vale).


Until next time!

- Evan Ovadia


<ignore>
Even though I spend most of my time writing in Vale, Rust, and Scala, I'm a C++ programmer at heart. Once you look past the legacy nonsense, it has a really nice combination of speed and flexibility that no other mainstream language has really nailed.

That combination inspired me make [Vale](https://vale.dev/), to see if we could make a high-performance language that has memory safety, but which also has that C++ flexibility and spirit. And in that quest, I've discovered some *surprising truths*.

Languages like [Carbon](https://github.com/carbon-language/carbon-lang) and [CppFront](https://github.com/hsutter/cppfront) could even implement them as first-party concepts.
</ignore>


<$include "/sponsoring.vmd" />
