---
title: Single Ownership and Memory Safety without Borrow Checking, Reference Counting, or Garbage Collection
subtitle: And why we love it!
realm: blog
date: May X, 2023
path: blog/single-ownership-without-borrow-checking-rc-gc
layout: annotated
author: Evan Ovadia
sponsor: me
namespace: c-blog m-annotated
---


Single ownership is once of those concepts that's both easier and more powerful than we realize.


Alas, people often think single ownership is more complex than it really is, because it most often appears in languages that are already complex for separate reasons.


I want to dispel that myth, and redesign it from first principles.


Even if you already know what single ownership is, you'll probably find some interesting surprises:

 * You don't need a borrow checker for memory-safe single ownership.
 * You can use it to enforce all sorts of guarantees at compile time.
 * You can blend it with other memory management techniques!


Below, I'll explain single ownership from a C foundation, and then we'll see the _weird_ things it can do.


# We often track single ownership manually in C

With manual memory management, we usually make it clear who's responsible for eventually freeing certain memory, via documentation or naming.


For example, `strdup` will return a heap-allocated buffer, which the caller then owns. GLib's `strdup` [documentation](https://docs.gtk.org/glib/func.strdup.html) says "The caller of the function takes ownership of the data, and is responsible for freeing it."


We then make sure that we eventually deliver these "owned" data to another function that destroys them.


If we don't do that, we get a memory leak.

```c
void main() {
  char* myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  // uh oh, we forgot to free(myBuffer)!
}
```

If we accidentally do it multiple times, the program might crash or exhibit undefined behavior.

```c
void main() {
  char* myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  free(myBuffer);
  // Shenanigans ensue!
  free(myBuffer);
}
```


As any C programmer knows, we *carefully track who owns the data*, all the way from when it's created, to when it's finally destroyed.


At any given time in between, we can generally identify who conceptually "owns" certain data, whether it be a certain local variable or a field in some struct somewhere.


Of course, other pointers to the data can exist, they just down _own_ the data. We have a *mental distinction* between owning pointers and non-owning pointers.


If you've ever implemented a balancing binary search tree like a [red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) or an [AVL tree](https://en.wikipedia.org/wiki/AVL_tree), recall that a parent conceptually has "owning" pointers to its children, and its children have non-owning pointers back to their parents.


Single ownership isn't just for pointers and `malloc` and `free`, it's to anything that we have a *future responsibility* for.

For example, `pthread_create` creates a handle that we're responsible for eventually `pthread_destroy`ing. We generalize this a bit more later, but for now let's just think about heap allocations.


# How might we track it?

When I was a wee lad, I would suffix my "owning" pointers with `_owning` to keep things straight.


<<<<
Here's a balancing binary search tree node in regular C...

```c
struct Node {
  struct Node* parent;
  struct Node* leftChild;
  struct Node* rightChild;
};
```
////
...and here it is with some helpful `_owning`s added to the names.

```c
struct Node {
  struct Node* parent;
  struct Node* leftChild_owning;
  struct Node* rightChild_owning;
};
```
>>>>


I had some sensible guidelines:

*Rule 1:* Anything that comes from `malloc` must be put in a variable ending in `_owning`.

*Rule 2:* We can't let an `_owning` variable (or field) go out of scope, the only way to destroy it is to explicitly give it to `free` (or "move" it, which we'll talk about later).

*Rule 3:* We can't use that variable after freeing it (or moving it).


We could even make a linter or compiler to enforce this, and detect both memory leaks and double-frees:


```c
void main() {
  char* myBuffer_owning = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer_owning);

  // Take out this line for an error!
  free(myBuffer_owning)

  // Or add this bad line for a different error!
  // printf("Freed: %s\n", myBuffer_owning);
}
```



In a way, we're *tracking responsibility for freeing the buffer*.


Keep the phrase "tracking responsibility" in mind, we'll build on that later to make the system help us with much more than managing memory.


# How a compiler can track it


If we were to craft a C-like language, then instead of using a suffix like `char* myBuffer_owning`, we might use a symbol on the type, like: `char^ myBuffer`.


When you look at it that way, it's kind of like `char`, `char^`, and `char*` are all different types:

 * `char` is an *owned value*, owned by the containing stack frame, struct, or array.
 * `char^` is an *owning pointer* to something in the heap.
 * `char*` is a *non-owning pointer*.


The above `char* myBuffer_owning = ...` would become `char^ myBuffer = ...`.


However, for the compiler to be able to keep things straight, we also need to add the ability to `move` ownership from one variable into another variable or field:


```c
void main() {
  char^ myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  char^ otherVar = move myBuffer;
  // Now, we can't access myBuffer.

  free(move otherVar)
}
```



Notice how we `move`d from `myBuffer` to `otherVar`. We also moved into the `free` call as well.


This `move` keyword comes with a new rule.

*Rule 4:* When we `move` out of a variable, we can't use it anymore.


We would also use this new `move` keyword to transfer ownership of some data to our caller, like so:

```
Spaceship^ makeSpaceship() {
  Spaceship^ ship = (Spaceship^)malloc(sizeof(Spaceship));
  ship->fuel = 42;
  return move ship;
}
```



These rules are sometimes known as "move semantics".



# Let's keep it weird


C++ and Rust also have move semantics, but ours is a little different so far:

 * C++ doesn't have rule 4, in C++ the compiler lets us accidentally use the variable after we `move` out of it.
 * Rust adds a borrow checker on top. We're going to do something else!
 * Both C++ and Rust will automatically `free` an owning pointer when it goes out of scope.


Of course, we're not doing any of that.


Let's see what interesting things happen!


# Higher RAII, and compile-time guarantees

Recall Rule 2: We can't let an owning variable (or field) go out of scope, the only way to destroy it is to explicitly `move` it or give it to `free`.


Because of this, if you accidentally let an owning pointer go out of scope, you'll get a compiler error.


You can use this to your advantage, using a technique called "Higher RAII". [# Higher RAII is similar to linear typing. An owning reference is a linear type, but when we can also make non-owning references to the same object, we get Higher RAII.]

Basically, if you want your caller to remember to do something later, give them ownership of a "reminder" object.


This technique is incredibly powerful. With it, the compiler can enforce that you:

 * Remember to `fulfill` a `Promise` [# A `Promise` is an object that will deliver a result to a corresponding `Future`, sometimes on a different thread.] exactly once.
 * Remember to remove something from a cache that you previously added to.
 * Remember to explicitly rollback or commit a transaction.
 * Remember to join a thread and do something with the thread function's result.


More generally, it means the compiler can *ensure you remember to do something in the future* and don't accidentally forget it.


## An Example


Lets say we have a spaceship game.


Some facts about our game's code:

 * All of our spaceships live in a central list.
 * We _also_ need to have a separate cache for displaying them.
 * Every ship needs to be in both the central list _and_ the display cache.
 * When the ship dies, we need to remove it from both the central list _and_ the display cache.


If we forget to remove it from the display cache, we'd get an odd bug when displaying.


Let's use single ownership to prevent this bug at compile-time.


We already have a function that will add the ship to the display cache, which looks like this:


```c
void AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache
}
```



Let's instead return a "reminder" object:


```
struct ShipInCacheReminder { };

ShipInCacheReminder^ AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache
  // Return a zero-sized reminder object
  return (ShipInCacheReminder^)malloc(sizeof(ShipInCacheReminder));
}
```



The compiler prevents us from accidentally dropping this `ShipInCacheReminder^`; we must explicitly `move` or `free` it. That makes it a very effective reminder.


The only place we'll ever `free` it is in the `RemoveShipFromDisplayCache` function:


```
void RemoveShipFromDisplayCache(
    DisplayCache* cache,
    Ship* ship,
    ShipInCacheReminder^ reminder) {
  free(move reminder);
  ... // Remove it from the cache
}
```



Voil√†! The compiler now guarantees that we'll not forget to `RemoveShipFromDisplayCache`.


As a bonus, it prevents us from accidentally `RemoveShipFromDisplayCache` twice, because there's only one `reminder` object.


They say the biggest two problems in computer science are off-by-one errors and cache invalidation. We just solved the latter!


If you want to learn more about this, check out [Vale's Higher RAII, the pattern that saved me a vital 5 hours in the 7DRL Challenge](/blog/higher-raii-7drl), where I used this exact technique to remember to remove things from a cache.


# Memory Safety


Let's make something else amazing happen.


We can make our little C-like language *completely memory safe* with a few extra rules:

*Rule 5:* Always bounds-check array accesses.

*Rule 6:* No using pointer arithmetic.

*Rule 7:* Never use non-owning pointers. Each object only ever has one pointer to it, the owning pointer.


You're probably thinking, "That's insane! How can you make a program without non-owning pointers? And how does that make our programs memory safe?"


It does sound insane! But we can refactor any program to not use non-owning pointers, if we have these guidelines:

 1. Any function that receives a non-owning pointer would instead take (and return) ownership of data.
 1. Any struct that stores a non-owning pointer would instead store an index (or ID) into some central data structure.


If you've ever used a language with a [linear type system](https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems) like [Austral](https://austral-lang.org/), this will sound familiar.


After a few hours of using this "linear style", it actually feels pretty similar to Rust. The first guideline is semantically equivalent to passing an `&mut`, and we use the second gudeline all the time in Rust already.


# Adding non-owning pointers back in safely

If we want to add non-owning pointers back in while keeping our newfound memory safety, there are a few ways we can go about it.


## Memory Tagging and CHERI

[Memory tagging](https://source.android.com/docs/security/test/memory-safety/arm-mte) is when every 16-byte chunk of memory has a corresponding 4-bit "key" that goes with it. Every time we allocate or deallocate that chunk, we change the chunk's key.

Whenever we make a pointer to some data, we copy that key into the unused top bits of the pointer.

When we attempt to dereference the pointer, the hardware will assert that the key in the chunk matches the key in the pointer.


Even though these asserts have a 1/16 chance of a false negative, this is great for detecting bugs in development and testing.


[CHERI](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/) is still in the R&D phase, but it seems like it will solve a lot of memory tagging's downsides.


## Borrow Checking

Of course, there's always Rust's borrow checking approach! It enforces that if someone has a mutable reference to an object, no other references can exist. This simple rule gives us non-owning pointers with full memory safety.


It has some really nice benefits:

 * With a little bit of function coloring and data coloring, we can temporarily share data with multiple threads, without risking data races!
 * It doesn't have the run-time cost of memory tagging or CHERI (about [6.8%](https://lobste.rs/s/nw7hsd/how_memory_safe_is_zig_updated#c_tyzbaf)).


But also some drawbacks:

 * It can be difficult for time management and [development velocity](/blog/when-to-use-memory-safe-part-2).
 * It doesn't let us use common patterns like observers, graphs, back-references, dependency references, intrusive data structures, delegates, and struggles with certain kinds of RAII and interconnected data.
 * It doesn't let us use Higher RAII. [# This is because the borrow checker often forces non-owning reference fields to be function parameters instead, but destructors can't take in parameters.]


## Generational References

[Vale](https://vale.dev/)'s [generational references](/blog/generational-references) is like a 64-bit memory tagging system, but it uses the language's semantics to skip as many assertions as the user wants.


It has a some benefits:

 * It skips the assertions when we access an owning pointer, or when reading from an immutable [region](/blog/zero-cost-borrowing-regions-overview). Between these, one can eliminate every single assertion in a program if they want.
 * Its owning references are regular thin 64-bit pointers, as opposed to CHERI's 128-bit ones.
 * It's easy, and lets us use whatever patterns we want.
 * It can be used with [regions](/blog/zero-cost-borrowing-regions-overview) to eliminate data races.


It has its drawbacks too, of course:

 * It has a "key" at the top of every allocation, though structs and enums share the key of the containing struct, array, or stack frame to save space.
 * Its non-owning references are 128 bits (like CHERI's), though they can be avoided with the above linear style.


This combination of generational references and regions is my favorite approach, especially since it still lets us use Higher RAII.


# What does it all mean?

Single ownership is a _lot_ more powerful than we thought. Even without reference counting, garbage collection, or borrow checking, we can use it for memory safety _and_ extra guarantees at compile-time.



*That's all for now!* I hope you enjoyed this article. Keep an eye out for the next one on our [RSS feed](https://verdagon.dev/rss.xml), [twitter](https://twitter.com/vale_pl), [discord server](https://discord.gg/SNB8yGH), or [subreddit](https://reddit.com/r/vale)!


If you're impressed with our [track record](https://vale.dev/roadmap#recent-additions) and believe in the [direction we're heading](https://vale.dev/roadmap), please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>


See you next time!

- Evan Ovadia


<slice new-color="afterword"/>

# Vale's Vision

Vale aims to bring a new way of programming into the world that offers *speed*, *safety*, and *ease of use.*


*The world needs something like this!* Currently, most programming language work is in:

 * High-overhead languages involving reference counting and tracing garbage collection.
 * Complex languages (Ada/Spark, Coq, Rust, Haskell, etc.) which impose higher complexity burden and mental overhead on the programmer.

These are useful, but there is a *vast field of possibilities* in between, waiting to be explored!


Our aim is to explore that space, discover what it has to offer, and make *speed and safety easier than ever before.*


In this quest, we've discovered and implemented a lot of new techniques:

 * [Generational Memory](/blog/generational-references), for a language to ensure an object still exists at the time of dereferencing.
 * [Higher RAII](/blog/raii-next-steps), a form of linear typing that enables destructors with parameters and returns.
 * [Fearless FFI](/blog/fearless-ffi), which allows us to call into C without risk of accidentally corrupting Vale objects.
 * [Perfect Replayability](/blog/perfect-replayability-prototyped), to record all inputs and replay execution, and completely solve heisenbugs and race bugs.


These techniques have also opened up some new emergent possibilities, which we hope to implement:

 * [Region Borrow Checking](/blog/zero-cost-borrowing-regions-overview), which adds mutable aliasing support to a Rust-like borrow checker.
 * [Hybrid-Generational Memory](/blog/hybrid-generational-memory), which ensures that nobody destroys an object too early, for better optimizations.
 * [Seamless concurrency](/blog/seamless-fearless-structured-concurrency), the ability to launch multiple threads that can access any pre-existing data without data races, without the need for refactoring the code or the data.
 * Object pools and bump-allocators that are memory-safe and decoupled, so no refactoring needed.


We also gain a lot of inspiration from other languages, and are finding new ways to combine their techniques:

 * We can mix an `unsafe` block with Fearless FFI to make a much safer systems programming language!
 * We can mix Erlang's isolation benefits with functional reactive programming to make much more resilient programs!
 * We can mix region borrow checking with Pony's `iso` to support shared mutability.

...plus a lot more interesting ideas to explore!


The Vale programming language is a novel combination of ideas from the research world and original innovations. Our goal is to publish our techniques, even the ones that couldn't fit in Vale, so that the world as a whole can benefit from our work here, not just those who use Vale.


Our medium-term goals:

 * Finish the Region Borrow Checker, to show the world that shared mutability can work with borrow checking!
 * Prototype Hybrid-Generational Memory in Vale, to see how fast and easy we can make single ownership.
 * Publish the Language Simplicity Manifesto, a collection of principles to keep programming languages' learning curves down.
 * Publish the Memory Safety Grimoire, a collection of "memory safety building blocks" that languages can potentially use to make new memory models, just like Vale combined generational references and scope tethering.


We aim to publish articles biweekly on all of these topics, and create and inspire the next generation of fast, safe, and easy programming languages.


If you want to support our work, please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

With enough sponsorship, we can:

 * Work on this full-time.
 * Turn the Vale Language Project into a 501(c)(3) non-profit organization.
 * Make Vale into a production-ready language, and push it into the mainstream!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>






