---
title: Single Ownership and Memory Safety, without Borrow Checking, RC, or GC
subtitle: And why we love it!
realm: blog
path: blog/single-ownership-c-perspective
layout: annotated
namespace: c-blog m-annotated
---


Single ownership is once of those concepts that's both easier and more powerful than we realize.


Unfortunately, it's often seen as complex, because of the incidental complexity added by today's languages. However, single ownership doesn't need C++'s syntactical legacy or Rust's complexity difficulties.


Single ownership is actually really simple.


When we dive into it, we discover some interesting surprises:

 * You don't need a borrow checker for memory-safe single ownership.
 * You can use it to enforce all sorts of guarantees at compile time.
 * With generational references, you can safely use intrusive data structures.


Below, I'll explain single ownership from a C foundation, and then build on it to show how.


# We often track single ownership manually in C

With manual memory management, we make it clear who's responsible for eventually freeing certain memory.


For example, `strdup` will return a heap-allocated buffer, which the caller then owns. GLib's `strdup` [documentation](https://docs.gtk.org/glib/func.strdup.html) says "The caller of the function takes ownership of the data, and is responsible for freeing it.""


It's not just pointers, we often receive opaque handles. For example, `pthread_create` create a handle that we're responsible for eventually freeing.


We then make sure that we eventually deliver these "owned" data to another function that destroys them, such as `free` or `pthread_join` respectively.


If we don't do that, we get a memory leak.

```c
void main() {
  char* myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  // uh oh, we forgot to free(myBuffer)!
}
```

If we accidentally do it multiple times, the program might crash or exhibit undefined behavior.

```c
void main() {
  char* myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  free(myBuffer);
  // Shenanigans ensue!
  free(myBuffer);
}
```


As any C programmer knows, we *carefully track who owns the data*, all the way from when it's created, to when it's finally destroyed.


At any given time in between, we can generally identify who conceptually "owns" certain data, whether it be a certain local variable or a field in some struct somewhere.


Of course, other pointers to the data can exist, they just down _own_ the data. We have a *mental distinction* between owning pointers and non-owning pointers.


If you've ever implemented a balancing binary search tree like a [red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) or an [AVL tree](https://en.wikipedia.org/wiki/AVL_tree), recall that a parent conceptually has "owning" pointers to its children, and its children have non-owning pointers back to their parents.


# How might we track it?

When I was a wee lad, I would suffix my owning pointers with `_owning` to keep things straight.


<<<<
Here's a balancing binary search tree node in regular C...

```c
struct Node {
  struct Node* parent;
  struct Node* leftChild;
  struct Node* rightChild;
};
```
////
...and here it is with some helpful `_owning`s added.

```c
struct Node {
  struct Node* parent;
  struct Node* leftChild_owning;
  struct Node* rightChild_owning;
};
```
>>>>


This came with some sensible guidelines:

*Rule 1:* Anything that comes from `malloc` must be put in a variable ending in `_owning`.

*Rule 2:* We can't let an `_owning` variable (or field) go out of scope, the only way to destroy it is to explicitly give it to `free` (or "move" it, which we'll talk about later).

*Rule 3:* We can't use that variable after freeing it (or moving it).


We could even make a linter to enforce this, and detect both memory leaks and double-frees:


```c
void main() {
  char* myBuffer_owning = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer_owning);

  // Take out this line for an error!
  free(myBuffer_owning)

  // Or add this bad line for a different error!
  // printf("Freed: %s\n", myBuffer_owning);
}
```


In a way, our it's *tracking responsibility for freeing the buffer*.


Keep the phrase "tracking responsibility" in mind, we'll build on that later to make the system help us with much more than managing memory.


# How a compiler can track it


If we were to craft a C-like language, then instead of using a suffix like `char* myBuffer_owning`, we might use a symbol on the type, like: `char^ myBuffer`.


When you look at it that way, it's kind of like `char`, `char^`, and `char*` are all different types:

 * `char` is an *owned value*; it's owned by the stack, or inside the containing struct or array.
 * `char^` is an *owning pointer* to something in the heap.
 * `char*` is a *non-owning pointer*.


The above `char* myBuffer_owning = ...` would become `char^ myBuffer = ...`.


However, for the compiler to be able to keep things straight, we need to add the ability to `move` ownership from one variable into another variable or field:


```c
void main() {
  char^ myBuffer = GetRealPath("./myfile.txt");

  // prints: /Users/Valerian/Bogglewoggle/myfile.txt
  printf("Real path: %s\n", myBuffer);

  char^ otherVar = move myBuffer;
  // Now, we can't access myBuffer.

  free(move otherVar)
}
```



Notice how we `move`d from `myBuffer` to `otherVar`. We also moved into the `free` call as well.


This `move` keyword comes with a new rule.

*Rule 4:* When we `move` out of a variable, we can't use it anymore.


We would also use `move` to transfer ownership of some data to our caller, like so:

```
Spaceship^ makeSpaceship() {
  Spaceship^ ship = (Spaceship^)malloc(sizeof(Spaceship));
  ship->fuel = 42;
  return move ship;
}
```



These rules are sometimes known as "move semantics".



# Let's keep it weird


C++ and Rust also have move semantics, but ours is a little different so far:

 * C++ doesn't have rule 4, we might accidentally use the variable after we `move` out of it.
 * Rust adds a borrow checker on top. We're going to do something else!
 * Both C++ and Rust will automatically `free` an owning pointer when it goes out of scope.


Of course, we're not doing any of that.


Let's see what interesting things happen!


# Higher RAII, and compile-time guarantees

Recall Rule 2: We can't let an owning variable (or field) go out of scope, the only way to destroy it is to explicitly `move` it or give it to `free`.


Because of this, if you accidentally let an owning pointer go out of scope, you'll get a compiler error.


Instead, the compiler forces the programmer to _explicitly_ `move` or `free` it.


You can use this to your advantage, using a technique called "Higher RAII". Basically, if you want your caller to remember to do something later, give them ownership of a "reminder" object.


This technique is incredibly powerful. With it, the compiler can enforce that you:

 * Remember to `fulfill` a `Promise` [# A `Promise` is an object that will deliver a result to a corresponding `Future`, sometimes on a different thread.] exactly once.
 * Remember to remove something from a cache that you previously added to.
 * Remember to explicitly rollback or commit a transaction.
 * Remember to join a thread and do something with the thread's main function's result.


More generally, it means the compiler can *ensure you remember to do something in the future* and don't accidentally forget to.


## An Example


Lets say we have a spaceship game.


All of our spaceships live in a central list, but we also need to have a separate cache for displaying them.


Every ship needs to be in both the central list _and_ the display cache.


When the ship dies, we need to remove it from both the central list _and_ the display cache. If we forget to remove it from the display cache, we get odd bugs on the screen.


Let's use single ownership to prevent this bug at compile-time.


We already have a function that will add the ship to the display cache, which looks like this:


```c
void AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache
}
```


We're going to return a "reminder" object:


```
struct ShipInCacheReminder { };

ShipInCacheReminder^ AddShipToDisplayCache(DisplayCache* cache, Ship* ship) {
  ... // Add to cache

  // Return a zero-sized reminder object
  return (ShipInCacheReminder^)malloc(sizeof(ShipInCacheReminder));
}
```


The compiler prevents us from accidentally dropping this object, and doesn't automatically `free` it. We must explicitly `move` or `free` it, which makes it a very effective reminder.


The only place we'll ever `free` it is in the `RemoveShipFromDisplayCache` function:


```
void RemoveShipFromDisplayCache(DisplayCache* cache, Ship* ship, ShipInCacheReminder^ reminder) {
  free(move reminder);

  ... // Remove it from the cache
}
```


Voil√†! The compiler now guarantees that we'll not forget to `RemoveShipFromDisplayCache`.


As a bonus, it prevents us from accidentally `RemoveShipFromDisplayCache` twice, because there's only one `reminder` object.


They say the biggest two problems in computer science are off-by-one errors and cache invalidation. We just solved the latter.


If you want to learn more about this, check out [Vale's Higher RAII, the pattern that saved me a vital 5 hours in the 7DRL Challenge](/blog/higher-raii-7drl), where I used this exact technique to remember to remove things from a cache.


# Memory Safety

With a few extra rules, something amazing happens.

*Rule 5:* Always bounds-check array accesses.

*Rule 6:* No using pointer arithmetic.

*Rule 7:* Never use non-owning pointers. Each object only ever has one pointer to it, the owning pointer.


Suddenly, our programs magically become *completely memory-safe*.


You're probably thinking, "That's insane! How can you make a program without non-owning pointers? And how does that make our programs memory safe?"


It does sound insane! But we can refactor any program to not use non-owning pointers, if we have these guidelines:

 1. Any function that receives a non-owning pointer would instead take (and return) ownership of data.
 2. Any struct that stores a non-owning pointer would instead store an index (or ID) into some central data structure.


If you've ever used a language with a [linear type system](https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems), this will sound familiar.


After a few hours of using this "linear style", it actually feels pretty similar to Rust. The first point is semantically equivalent to passing an `&mut`, and we use the second gudeline all the time in Rust already.


At this point, we _could_ add non-owning pointers back in, if we use restrictive rules, akin to Rust's borrow checking.


But let's do something more interesting! And after all, borrow checking means we can't use a lot of useful patterns, like graphs, observers, back-references, dependency-references, delegates, or intrusive data structures.



# CHERI, Memory Tagging, Generational References

There are three ways to make non-owning pointers safe enough to add back in.


[Memory tagging](https://source.android.com/docs/security/test/memory-safety/arm-mte) is when every 16-byte chunk of memory has a corresponding 4-bit "key" that goes with it. Every time we allocate or deallocate that chunk, we change the chunk's key.

Whenever we make a pointer to some data, we copy that key into the unused top bits of the pointer.

When we attempt to dereference the pointer, the hardware will assert that the key in the chunk matches the key in the pointer.


This has a 1/16 chance of a false positive, and there's also some ways around it. [CHERI](https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/) solves both of those problems, by making it so the key is unforgeable.


[Vale](https://vale.dev/)'s [generational references](https://verdagon.dev/blog/generational-references) are similar to memory tagging, but with a 64-bit generation at the top of every allocation. It has a couple extra benefits:

 * It skips the assertions when we access an owning pointer. We can use the above "linear style" to eliminate all assertions in any program.
 * It skips the assertions when reading from an immutable [region](https://verdagon.dev/blog/zero-cost-borrowing-regions-overview).


Any of these three approaches will let us add non-owning pointers back to our language while still being memory safe.


# What does it all mean?

Single ownership is a _lot_ more powerful than we thought. Even without borrow checking, we can do everything we used to, but with extra compiler guarantees, and not just about memory safety.



*That's all for now!* I hope you enjoyed this article. Keep an eye out for the next one on our [RSS feed](https://verdagon.dev/rss.xml), [twitter](https://twitter.com/vale_pl), [discord server](https://discord.gg/SNB8yGH), or [subreddit](https://reddit.com/r/vale)!


If you're impressed with our [track record](https://vale.dev/roadmap#recent-additions) and believe in the [direction we're heading](https://vale.dev/roadmap), please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>

With your support, we can bring regions to programmers worldwide.


See you next time!

- Evan Ovadia


<slice new-color="afterword"/>

# Vale's Vision

Vale aims to bring a new way of programming into the world that offers *speed*, *safety*, and *ease of use.*


*The world needs something like this!* Currently, most programming language work is in:

 * High-overhead languages involving reference counting and tracing garbage collection.
 * Complex languages (Ada/Spark, Coq, Rust, Haskell, etc.) which impose higher complexity burden and mental overhead on the programmer.

These are useful, but there is a *vast field of possibilities* in between, waiting to be explored!


Our aim is to explore that space, discover what it has to offer, and make *speed and safety easier than ever before.*


In this quest, we've discovered and implemented a lot of new techniques:

 * [Generational Memory](/blog/generational-references), for a language to ensure an object still exists at the time of dereferencing.
 * [Higher RAII](/blog/raii-next-steps), a form of linear typing that enables destructors with parameters and returns.
 * [Fearless FFI](/blog/fearless-ffi), which allows us to call into C without risk of accidentally corrupting Vale objects.
 * [Perfect Replayability](/blog/perfect-replayability-prototyped), to record all inputs and replay execution, and completely solve heisenbugs and race bugs.


These techniques have also opened up some new emergent possibilities, which we hope to implement:

 * [Region Borrow Checking](/blog/zero-cost-borrowing-regions-overview), which adds mutable aliasing support to a Rust-like borrow checker.
 * [Hybrid-Generational Memory](/blog/hybrid-generational-memory), which ensures that nobody destroys an object too early, for better optimizations.
 * [Seamless concurrency](https://verdagon.dev/blog/seamless-fearless-structured-concurrency), the ability to launch multiple threads that can access any pre-existing data without data races, without the need for refactoring the code or the data.
 * Object pools and bump-allocators that are memory-safe and decoupled, so no refactoring needed.


We also gain a lot of inspiration from other languages, and are finding new ways to combine their techniques:

 * We can mix an `unsafe` block with Fearless FFI to make a much safer systems programming language!
 * We can mix Erlang's isolation benefits with functional reactive programming to make much more resilient programs!
 * We can mix region borrow checking with Pony's `iso` to support shared mutability.

...plus a lot more interesting ideas to explore!


The Vale programming language is a novel combination of ideas from the research world and original innovations. Our goal is to publish our techniques, even the ones that couldn't fit in Vale, so that the world as a whole can benefit from our work here, not just those who use Vale.


Our medium-term goals:

 * Finish the Region Borrow Checker, to show the world that shared mutability can work with borrow checking!
 * Prototype Hybrid-Generational Memory in Vale, to see how fast and easy we can make single ownership.
 * Publish the Language Simplicity Manifesto, a collection of principles to keep programming languages' learning curves down.
 * Publish the Memory Safety Grimoire, a collection of "memory safety building blocks" that languages can potentially use to make new memory models, just like Vale combined generational references and scope tethering.


We aim to publish articles biweekly on all of these topics, and create and inspire the next generation of fast, safe, and easy programming languages.


If you want to support our work, please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

With enough sponsorship, we can:

 * Work on this full-time.
 * Turn the Vale Language Project into a 501(c)(3) non-profit organization.
 * Make Vale into a production-ready language, and push it into the mainstream!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>






