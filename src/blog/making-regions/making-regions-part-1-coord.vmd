---
title: Implementing a New Memory Safety Approach with Vale Regions, Part 1
subtitle: A new paradigm, for easy and flexible speed and safety!
author: Evan Ovadia
date: Draft, Preview
realm: blog
path: blog/implementing-regions-part-1-coord
layout: annotated
namespace: c-blog m-annotated
sponsor: us
---


In late 2019, I was lying in bed listening to my [favorite fanfiction podcast](https://www.hpmor.com/) for the 47th time, [# The series really is that good, [give it a listen](https://hpmorpodcast.com/)!] drifting in and out of sleep and bouncing between the various features and bugs I'd programmed that day.


Suddenly, my eyes flew open as a realization hit me.


That 2:00am realization sparked a chain reaction of events that spanned years, and led to the discovery of *an entire new memory safety paradigm.*


This is the first post (of hopefully many!) about creating, designing, and implementing [regions](/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing) in Vale.


# Chronobase, Superstructures, and "Regions"

<img width="100%" src="/images/incendian2.png" />


In the [7DRL Challenge](https://7drl.com/), I created a game [Incendian Falls](https://verdagon.itch.io/incendian-falls), which involved *time traveling to team up with your past self* to defeat hordes of enemies.


Time traveling is _hard_ to do efficiently; one cannot simply copy the entire game state for every turn. Instead, I used [journaling](https://en.wikipedia.org/wiki/Journaling_file_system) and [persistent hash maps](https://en.wikipedia.org/wiki/Persistent_data_structure) to be able to reconstruct the game state from any point in time, in a tool I called the *chronobase*.


In time-honored fashion, I then made a [domain specific language](https://en.wikipedia.org/wiki/Domain-specific_language) named [VSS](https://github.com/Verdagon/IncendianFalls/tree/master/ChronobaseCS/resources) (Vale Superstructure) and a [tiny Scala-based compiler](https://github.com/Verdagon/IncendianFalls/tree/master/ChronobaseCS) to convert it into the code I needed for the chronobase.


It worked beautifully! And by the end of the week, I had so many kinds of items, enemies, tiles, and components in the game that the resulting generated code was over [150,000 lines](https://github.com/Verdagon/IncendianFalls/tree/master/Atharia/Atharia/Core).


Eventually, I realized that the chronobase could be used for more than just a game. It could be used for a word processor, an image editing tool, anything with an undo history or save history.


In fact, if we added [stored procedures](https://en.wikipedia.org/wiki/Stored_procedure) and made it completely deterministic, we could have it record all of its inputs and be able to perfectly replay and reproduce any bugs we encountered. I added that in, and it later inspired Vale's [Perfect Replayability](https://verdagon.dev/blog/perfect-replayability-prototyped) feature.


Late 2019 came around, and I was thinking about how we might make it so these stored procedures could read data from the outside world.


At 2am that night, it occurred to me that *the type system could track that.* A `req'Spaceship` would be a Spaceship from the outside, and a `db'Spaceship` would be a spaceship inside the database.


This idea eventually led to the design of Vale's [pure functions](https://verdagon.dev/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing).


# An Alien Concept


I feverishly scribbled it in a notebook until 3am, and then finally fell asleep. When I woke up, I discovered this notebook, and read the page.


"...what the hell am I looking at?"


This was a common occurrence, honestly. "Notes from Night Evan" is an ongoing joke in my circle, about the weirdest things I'd written to myself. And this was definitely up there.


"Huh."


It _kind of_ made sense.


And then I noticed a triple-underlined statement: *"can skip reference counting overhead! Vale?"*.


"Holy crap!" I said to myself and sprang out of bed. It all came rushing back, and I finally remembered all the details.


At the time, Vale was an experimental language based on a single-ownership form of reference counting called [constraint references](https://verdagon.dev/blog/raii-next-steps), and Night Evan had realized that references into immutable regions could [completely skip the reference counting overhead](https://verdagon.dev/blog/zero-cost-refs-regions). Nowadays, Vale is based on [generational references](/blog/generational-references), but regions have the same optimizing effect for them too.


This was a _major game changer._ A few months later, I decided to do whatever it took to make Vale a complete language, so the world could see what was possible with regions.


# Other Alien Concepts


I started seeing regions _everywhere_. They were some sort of unifying generalized form of affine typing (one of the concepts underlying Rust's borrow checker), Pony's iso permission, Pony's [iso permission](https://tutorial.ponylang.io/reference-capabilities/reference-capabilities.html#isolated-data-is-safe), and a bunch of other languages' special cases.


I posted [Zero-Cost References with Regions in Vale](https://verdagon.dev/blog/zero-cost-refs-regions), and people started reaching out to me about other designs in the space. I had a call with [Forty2](http://forty2.is/)'s Marco Servetti and we talked for hours about our different takes on regions, and someone shared [Milano, Turcotti, and Myers](https://www.cs.cornell.edu/andru/papers/gallifrey-types/gallifrey-types.pdf)'s work on concurrency models.


The biggest revelation came when I was lying on the floor in a random Georgia AirBnB [# The house was called "Little Mexico" and had nary a square foot of unoccupied wall space, it was so full of Mexico decorations. Hands-down one of the coolest AirBnBs ever.] When I realized that we could blend region annotations to make "one-way isolation". But that's a story for a few posts from now!


Later, I even found a way to use regions to obviate most of [Hybrid-Generational Memory](https://verdagon.dev/blog/hybrid-generational-memory), another concept I was pursuing in Vale.


Eventually, generational references and regions combined to form an entire new paradigm. One person in our server described it as a "higher-level, opt-in Rust".


# The Design


I'm describing the full design in a parallel series, [Zero-Cost Memory Safety with Vale Regions](/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing):

 * [Part 1](/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing) talks about how we can use pure functions to establish immutable regions, and then access that memory with zero overhead.
 * [Part 2](/blog/zero-cost-memory-safety-regions-part-2-isolates) covers how we don't need a pure function to establish an immutable region! We can have an isolated sub-region (we have the only reference to it) and open it immutably.
 * [Part 3](/blog/zero-cost-memory-safety-regions-part-3-one-way-isolation) shows how we can enable "one-way isolation", for sub-regions to have references outside their own region, and how we can eliminate generation checks for private data.
 * [Part 4](/blog/zero-cost-memory-safety-regions-part-4-multi-region-data) talks about how an object or array can contain other regions' objects inline, which helps automatically eliminate generation checks for [data-oriented designs](https://en.wikipedia.org/wiki/Data-oriented_design) like [entity component systems](https://en.wikipedia.org/wiki/Entity_component_system).
 * [Part 5](/blog/zero-cost-memory-safety-regions-part-5-region-scoped-data) shows how regions can make iteration much faster, and how to use regions to make entire architectures (such as [entity-component-system](https://en.wikipedia.org/wiki/Entity_component_system)) zero-cost.


Take a look! But note that these are just a preview of how it _will_ work, not how it works today.


# Implementing It


Implementing something like this is no easy task, especially when one has a full-time job. Luckily, I recently dropped down to part-time, which gave me enough time to really make progress on all of this.


2021 and most of 2022 were spent laying the foundations we would need for regions:

 * Instead of C++-style templates, I transitioned the Vale compiler to full generics, which would help with the more interesting monomorphization tricks that would make regions even more composable than traditional borrow checking.
 * I refactored the backend to decouple the memory management strategy from the code itself, and added two "regions" to start out: raw and generational references. [# I later even used this to benchmark generational references!]
 * I rounded out the rest of the compiler's unfinished in-progress features, such as [Higher RAII](https://verdagon.dev/blog/higher-raii-7drl), [Fearless FFI](https://verdagon.dev/blog/fearless-ffi), [Perfect Replayability](https://verdagon.dev/blog/perfect-replayability-prototyped), internal namespacing, and a faster generics solver. Regions is a massive endeavor that will break _everything_ that's not already finished and well-tested, so I spent some time to finish and add tests for these features.


Finally, a month ago, I was able to start adding regions to the frontend.


# Tackling the Details


When designing a large system like a language, one gets a sense for what open questions are central to a design, and what open questions are peripheral. Peripheral concerns can be left for later, to preserve limited mental bandwidth and sanity.




I hit one such open question almost immediately: *Is the region part of the reference, or part of the type?*


Let's unpack that question, and see what it's really asking.


To the user, we can have a `r'Spaceship`; that `r'` is something independent of the type (`Spaceship`) and the type doesn't need to know that it's in one region or the other. Rather, the `r'` is part of the _reference_.


However, we don't have to represent it that way under the hood. We _could_ make it so:

 * The parser transforms that `r'Spaceship` to `Spaceship<r'>`. Now, `r'` is part of the _type_.
 * Have a rule that every type implicitly has at least one region parameter.
 * Consider any type to be "in" its last region parameter.

This can simplify some of the implementation, for arcane reasons I won't go into here.


A similar design question comes up in other languages:

 * In C#, a `class Spaceship { ... }` can instead be a `struct Spaceship { ... }`. We only ever have references to a class. We can never have a reference to a struct, we only have copies of it and hold them directly. C does the other approach, and leaves it up to the user to say `Spaceship` vs `Spaceship*`. The C approach is slightly more flexible.
 * In Rust, whether a function is async depends on the function definition. In Zig, a function can be async or not [depending on how it's used](https://kristoff.it/blog/zig-colorblind-async-await/). Rust later backtracked, and is trying to achieve the same thing with [keyword generics](https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html).


There are a few interesting other factors:

 * Strings can't have region parameters. There's no such thing as a `str<r'>`... yet we want to separately track different regions' strings.
 * There may be other types that arent structs, but we want to track their region. For example, we might want an opaque handle to some native memory.
 * In Vale, a struct can actually _own_ data in other regions. This might seem unrelated, but it rules out some clever perspectives we can use to resolve this decision.


These seem to suggest that we should go with the first option: have it has part of the reference. However, I'm actually going to go with a surprise third option: *have it in both,* at least for structs.


In other words, if it's a struct, then `r'Spaceship` will actually be lowered to `r'Spaceship<r'>`. This should give us a lot of the implementation simplifications, and it also leaves open the door to take out one or the other later on.


Redundancies like this can be dangerous sometimes, if they can become out of sync. However, as long as we have assertions that upholds this redundancy, there's no problems.


With that, the next step is to get a basic pure function working!


# Uncomfortably Exciting


At my old job, we often used the phrase "uncomfortably exciting" to describe when you're a bit scared of your own idea. That definitely captures how I'm feeling right now.


This idea has been _years_ in the making, and it's finally happening now that all the foundations are complete. And if it's as good as I think it is, it will completely change the way some of us program.


*That's all for now!* I hope you enjoyed this article. Keep an eye out for the next one on our [RSS feed](https://verdagon.dev/rss.xml), [twitter](https://twitter.com/vale_pl), [discord server](https://discord.gg/SNB8yGH), or [subreddit](https://reddit.com/r/vale)!



If you're impressed with our [track record](https://vale.dev/roadmap#recent-additions) and believe in the [direction we're heading](https://vale.dev/roadmap), please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>

With your support, we can bring regions to programmers worldwide.


See you next time!

- Evan Ovadia


<slice new-color="afterword"/>

# Vale's Vision

Vale aims to bring a new way of programming into the world that offers *speed*, *safety*, and *ease of use.*


*The world needs something like this!* Currently, most programming language work is in:

 * High-overhead languages involving reference counting and tracing garbage collection.
 * Complex languages (Ada/Spark, Coq, Rust, Haskell, etc.) which impose higher complexity burden and mental overhead on the programmer.

These are useful, but there is a *vast field of possibilities* in between, waiting to be explored!


Our aim is to explore that space, discover what it has to offer, and make *speed and safety easier than ever before.*


In this quest, we've discovered and implemented a lot of new techniques:

 * [Generational Memory](/blog/generational-references), for a language to ensure an object still exists at the time of dereferencing.
 * [Higher RAII](/blog/raii-next-steps), a form of linear typing that enables destructors with parameters and returns.
 * [Fearless FFI](/blog/fearless-ffi), which allows us to call into C without risk of accidentally corrupting Vale objects.
 * [Perfect Replayability](/blog/perfect-replayability-prototyped), to record all inputs and replay execution, and completely solve heisenbugs and race bugs.


These techniques have also opened up some new emergent possibilities, which we hope to implement:

 * [Region Borrow Checking](/blog/zero-cost-refs-regions), which adds mutable aliasing support to a Rust-like borrow checker.
 * [Hybrid-Generational Memory](/blog/hybrid-generational-memory), which ensures that nobody destroys an object too early, for better optimizations.
 * [Seamless concurrency](https://verdagon.dev/blog/seamless-fearless-structured-concurrency), the ability to launch multiple threads that can access any pre-existing data without data races, without the need for refactoring the code or the data.
 * Object pools and bump-allocators that are memory-safe and decoupled, so no refactoring needed.


We also gain a lot of inspiration from other languages, and are finding new ways to combine their techniques:

 * We can mix an `unsafe` block with Fearless FFI to make a much safer systems programming language!
 * We can mix Erlang's isolation benefits with functional reactive programming to make much more resilient programs!
 * We can mix region borrow checking with Pony's `iso` to support shared mutability.

...plus a lot more interesting ideas to explore!


The Vale programming language is a novel combination of ideas from the research world and original innovations. Our goal is to publish our techniques, even the ones that couldn't fit in Vale, so that the world as a whole can benefit from our work here, not just those who use Vale.


Our medium-term goals:

 * Finish the Region Borrow Checker, to show the world that shared mutability can work with borrow checking!
 * Prototype Hybrid-Generational Memory in Vale, to see how fast and easy we can make single ownership.
 * Publish the Language Simplicity Manifesto, a collection of principles to keep programming languages' learning curves down.
 * Publish the Memory Safety Grimoire, a collection of "memory safety building blocks" that languages can potentially use to make new memory models, just like Vale combined generational references and scope tethering.


We aim to publish articles biweekly on all of these topics, and create and inspire the next generation of fast, safe, and easy programming languages.


If you want to support our work, please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

With enough sponsorship, we can:

 * Work on this full-time.
 * Turn the Vale Language Project into a 501(c)(3) non-profit organization.
 * Make Vale into a production-ready language, and push it into the mainstream!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>


