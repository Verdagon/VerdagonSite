
Higher RAII examples:

 * Remember to `fulfill` or `reject` a `Promise` [# A `Promise` is an object that will deliver a result to a corresponding `Future`, sometimes on a different thread.] exactly once.
 * Cache invalidation: Remember to remove something from a cache that you previously added to.
    * For example, goblin: when we add a goblin to a cache, we create a token, and store it with the goblin.
 * Uphold data integrity:
    * DB row op in progress: when we mark it in progress, ensure we remember to mark it finished
    * Remember to explicitly rollback or commit a transaction, dont just automatically rollback.
 * Remember to join a thread and do something with the thread function's result, rather than just automatically assume we want to kill it.
 * Remember to explicitly force-close a TCP connection or wait for a graceful close. same with each individual request.
 * Remember to call a continuation/callback.
 * Unhandled messages: if you want something to be handled, make it a linear type! Every message that you expect to result in some sort of action should be a linear type.

defer and try-finally almost work, but they require you to have the data up-front, and they're tied to a certain scope, not a certain object's lifetime. you cant do the goblin cache thing with defer and try-finally.

putting members in objects almost works, but again, you need the data up-front, and borrow checking doesn't really let you put references in structs in practice, you end up making your codebase much more complex to accommodate the borrow checker.


context for downside: upwardly viral functions are bad. async/await and borrow checking are viral. if you're an async function, your parent will likely have to be an async function.

the downside: the data becomes upwardly virally linear.

"Must move types"
https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/

> Rust has lots of mechanisms that prevent you from doing something bad. But, right now, it has NO mechanisms that force you to do something good.