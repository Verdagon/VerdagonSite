---
title: Vale 0.2 Released: Concept Functions, Higher RAII, Const Generics, FFI, Modules, Faster Compiles, set Keyword
author: Evan Ovadia
date: Apr 18, 2022
realm: blog
path: blog/version-0.2-released
layout: annotated
namespace: c-blog m-annotated
sponsor: us
---


Well met!


# Higher RAII

This release enables [Higher RAII](https://verdagon.dev/blog/higher-raii-7drl), a form of linear typing that helps the compiler enforce that we "never forget to call that function".


To use Higher RAII, just add a `#!DeriveStructDrop` above your struct or `#!DeriveInterfaceDrop` above your interface, and then add your own function, which takes any number of arguments, returns whatever you'd like, and does `destruct self;` somewhere in its body.


For a real-world use case, check out [Vale's Higher RAII, the pattern that saved me a vital 5 hours in the 7DRL Challenge](https://verdagon.dev/blog/higher-raii-7drl).


# Concept Functions

Vale now supports *concept functions*, a way to specify that certain functions must exist for given generic parameters, without making them implement any traits.


For example, List's `clone` function can require that there exists a `clone` function for its elements:

```vale
func clone<T>(self &List<T>) List<T>
    where func clone(&T)T
{
  result = List<T>();
  foreach x in self {
    result.add(clone(x));
  }
  return result;
}
```

This is often much easier than what we normally see in mainstream languages, which is to require the element to implement a certain trait.

Read more at [Concept Functions](/blog/concept-functions)!


# Const Generics 

We're happy to announce that Vale now has "const generics", where generic parameters can contain not only types (like the `T` in `List<T>`) but also integers, booleans, and other types.


<<<<
Now, instead of repeating classes...

```vale
struct Vec2<T> {
  elements [#2]T; // 2-element array of T
}
struct Vec3<T> {
  elements [#3]T; // 3-element array of T
}
struct Vec4<T> {
  elements [#4]T; // 4-element array of T
}
```
////
...we can have one:

```vale
struct Vec<N int, T> {
  elements [#N]T;
}
```

We'd use it like `Vec<2, int>`.
>>>>


We also now have the *compile-time spread operator* `..` for structs, which enabled us to implement tuples in the standard library, instead of in the compiler.


We have some interesting things planned for const generics, see [Const Generics and the Compile-Time Spread Operator](/blog/const-generics-spread) for more!


# Removing Let and Let Mut

The 0.2 release removes the `let` and `let mut` keywords, making our syntax cleaner and more readable.

<<<<
Before:

```vale
func main() {
  let a = 3;
  let b = 3;
  let c = 3;
  let mut d = 3;
  d = 7;
  println(d);
}
```stdout
7
```
////
After:

```vale
func main() {
  a = 3;
  b = 3;
  c = 3;
  d = 3;
  set d = 7;
  println(d);
}
```stdout
7
```
>>>>

Read more at [On Removing Let and Let Mut](https://verdagon.dev/blog/on-removing-let-let-mut)!


# Faster Compile Times

This version of the compiler is 3x as fast as the previous version, after we did some optimizations:

 * Memoized all of our .hashCode() calls, and used interning to speed up .equals() calls.
 * Wrote a newly optimized generics solver, which operates on primitives instead of heap-allocated classes.
 * Migrated from Scala parser combinators to a hand-written recursive descent parser.

We plan on taking this optimization spree even further!


# Modules

Vale has a new take on modules, which is as easy to use as Java's packages and provides the flexibility of Rust's crates.


Check out the [https://vale.dev/guide/modules](Modules Guide) to see them!


We're also making use of our module system in a new standard library, stay tuned for more on that!


# Downcasting

We can now downcast interfaces to a specified struct, using the `as` function.

See the [Interfaces Guide](https://vale.dev/guide/interfaces) for more!


# Foreach and Break


<<<<
Vale now supports `foreach` loops, and the `break` statement as well.


Here's an example with both of them.


See the [Collections Guide](https://vale.dev/guide/collections#loops) for more!
////

```vale
exported func main() {
  l = List<int>().add(1).add(3).add(7);
  foreach [i, x] in l.entries() {
    println(i + ": " + x);
    if i == 1 {
      break;
    }
  }
}
```stdout
0: 1
1: 3
```: `import stdlib.*; import stdlib.collections.list.*;`
>>>>


# Fearless FFI

We've laid the groundwork for [Fearless FFI](/blog/next-fearless-ffi), by stabilizing how the user calls into external code.




