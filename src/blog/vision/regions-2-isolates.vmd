---
title: Zero-Cost Memory Safety with Vale Regions, Part 2: Isolates and Message Passing
subtitle: Watch how we split our memory into regions, for more performance!
author: Evan Ovadia
date: Draft
realm: blog
path: blog/zero-cost-memory-safety-regions-part-2-isolates
layout: annotated
namespace: c-blog m-annotated
sponsor: us
---


[# an iso object can come with an allocator attached to it perhaps... maybe that should be a special syntax or something. `MyAllocator^iso Fleet`]
[# perhaps this article should just have isos as messages between threads?]
[# nobody cares about iso objects. talk about zero cost message passing? maybe also talk about channels...]
[# talk about how this can harness the power of a borrow checker, without the AxM restrictions on objects.]
[# TODO: finish BenchmarkRL, think about how many checks might be eliminated by iso regions.]
[# Instead of eg `iso [][]bool`, can we say `'[][]bool`? An iso _is_ kind of like an anonymous region after all.]
[# Can we use `iso`s to create a pattern, and then we somehow freeze it for the rest of its lifetime? Would be super useful for Patterns.]
[# Talk about how we can combine iso regions and pure functions to make the outside immutable while keeping the inside mutable. Friggin crazy, if you ask me. This is what enables pure functions and seamless concurrency, if you squint. You can also flip back and forth: do that when constructing a thing, and then return the new thing as an immutable.]


! Generational references are complete but *the rest of these mechanisms are works in progress.* We'll be implementing these features over the next two years, per the [roadmap](https://vale.dev/roadmap).


Vale has an interesting challenge, to be *fast, safe, and easy.* There are a lot of stellar languages that have two, and we suspect it's possible to really maximize all three.


To do this, we're harnessing a new concept called *regions*. [Part 1](/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing) showed how we can use a `pure` function to "immutably borrow" a region, to eliminate memory safety costs when accessing it.


That works really well for the sections of our program that can be phrased as pure functions. [#puref]


We can use regions to eliminate memory safety overhead in other places too, using a concept called "isolates".


# Isolates

An *isolate* is a hierarchy of data that nobody outside can point to, except for one owning reference outside that points at the root.


Some examples:

 * If a Spaceship owns a private `Engine` field and nobody outside needs to access it, it's conceptually an isolate.
 * In an [entity-component-system](https://en.wikipedia.org/wiki/Entity_component_system) architecture, each separate component (and the arrays holding them) are isolates.
 * A webapp might choose to centralize each component's state into an isolate.
 * A compiler could put a stage's [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) into an isolate.
 * A message passed from one thread to another would be an isolate, giving a language [fearless concurrency](https://verdagon.dev/blog/seamless-fearless-structured-concurrency).


By default, nothing _inside_ an `iso` can point _out_ either, though Part 3 shows how we can enable that using *one-way isolation*. Most private data can actually be expressed very cleanly with one-way isolation. [# `pure` functions use it under the hood as well, if you squint hard enough.]

Part 4 also shows how one-way isolation can make certain patterns (iterating, determinants, etc.) and entire architectures (like [entity-component-system](https://en.wikipedia.org/wiki/Entity_component_system)) zero-cost. [# Together, `iso`lates, `pure` functions, and one-way isolation combine to form something that looks suspiciously like an entire new programming paradigm... whether that's true remains to be seen!]

For the rest of this post though, we'll focus on regular `iso`lates, where nothing inside can point out.


Most programs are naturally hierarchies of isolated data, [# More specifically, they're naturally hierarchies of _one-way_ isolated data. Private data often points outward, especially in stateful code.] no matter what language they're written in. `iso` can be used to help the compiler know where those isolates are, so it can make more optimal code. [# We can even take this to the extreme and make everything `iso`, and we'd end up with data roughly the same shape as in Rust programs. In practice, there's a balance somewhere in-between.]


One doesn't need to use `iso` for everything, of course. Consistent with Vale's philosophy of [reducing default complexity](https://www.nngroup.com/articles/progressive-disclosure/), `iso`lates are *opt-in*.

One would use `iso` on the parts of their program that profiling suggests would benefit from optimization.



<slice>
#puref: Which is quite a lot, really. Our sample roguelike game, a very stateful mutation-heavy program, actually spent PERCENT_HERE of its time inside pure functions.

DRAFT TODO: Figure out that figure. Pretty sure it's well above 90%; pathfinding, AI, and turn resolution take most of the time.
</slice>



# Zero-Cost Reading


We can immutably borrow an `iso`late's data, allowing the compiler to skip generation checks when reading it.


This is the same mechanism used by `pure` functions, described in [Part 1](/blog/zero-cost-memory-safety-regions-part-1-immutable-borrowing#how-regions-work).


This allows us to get the optimization benefits of affine types (like those seen in Rust and Cyclone), but with a vital improvement: it doesn't have aliasing restrictions, and enables techniques and optimizations that require shared mutability. [# Techniques like [intrusive data structures](https://lwn.net/Articles/907876/) and [graphs](https://news.ycombinator.com/item?id=24996001), plus useful patterns like [observers](https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/), [back-references](https://users.rust-lang.org/t/back-reference-to-the-parent-struct/7413/2), [dependency references](https://en.wikipedia.org/wiki/Dependency_injection), [callbacks](https://news.ycombinator.com/item?id=12029238), [delegates](https://medium.com/@nimjea/delegation-pattern-in-swift-4-2-f6aca61f4bf5) and many forms of RAII and [higher RAII](https://verdagon.dev/blog/higher-raii-7drl).]


# A Simple Example

Draft TODO: Show an example that's simpler than the one below. Perhaps just a simple function call? Or perhaps show how its easy and needs few annotations, as long as the two regions dont cross.


# A Real World Example


A common pattern is to open it up as mutable while we're building it, then close it, then reopen it as immutable when we only want to read it. Doing this helps eliminate memory safety overhead.


<<<<
Let's say we want a level generator for a simple game. We're going to *coalesce a black-and-white image's pixels* until it gives us something interesting, and then use that to inspire our level's terrain.


This is known as a Cellular Automata algorithm, and is very similar to blurring an image.
////
Draft TODO: Image here showing the various stages of a cellular automata run.
>>>>


<<<<
Here's our `main` function which shows the general structure of our program.


The `iso` in front of `[][]bool`, which specifies the array is isolated. [# Draft TODO: We might say `iso'` instead, TBD whether that's more confusing or less.]


The `image.imm` in `coalesceImage(&rand, image.imm)` will open up the `image` isolate as immutable, and then pass it in as an argument to coalesceImage.


Further below, we'll see how `coalesceImage` keeps the two inputs separate from each other.
////
```
exported func main() {
  // Our random number generator,
  // for the initial image and for
  // tiebreaking.
  rand = LCGRand(1337);

  // An isolated 30x20 array of bools.
  image = «imagetype»
      iso [][]bool(30, x => {
        iso []bool(20, y => {
          rand.next() mod 2 == 0
        })
      });

  // We want coalesceImage to treat
  // the input rand as mutable, and
  // the input image as immutable.
  image_coalesced =
      coalesceImage(&rand, image.imm);

  // And do it again, it'll look nice.
  image_coalesced_again =
      coalesceImage(
          &rand, image_coalesced.imm);

  display(image_coalesced_again.imm);
}
```
>>>>

<slice>
#imagetype: `image`'s type is `iso [][]bool`.
</slice>


Here's the `coalesceImage` function.


```
func coalesceImage<r'>(
  rand &LCGRand,
  tiles &r'[][]bool)
iso [][]bool { // Returns a new array.

  // Make a new isolated array.
  tiles iso [][]bool =
      foreach [x, column] in tiles.entries() { «foreachiso»
        foreach [y, walkable] in column.entries() {
          // Produces a boolean
          averageNeighbors(rand, tiles, x, y)
        }
      };
  return tiles;
}
```


The important part here is the `r'` in `&r'[][]bool`. It means this parameter is in a separate region from the rest of the parameters, and we only see the region as read-only. (In general, one can change `<r'>` to `<r' rw>` for a _read-write_ region here.)


When `main` calls coalesceImage, the compiler sees two things:

 * We're passing an `iso`lated object.
 * The function parameter sees it as from a read-only region.


The compiler concludes that nobody's going to change anything in the region, therefore it's temporarily immutable. It generates a `coalesceImage` function that is optimized accordingly, eliminating memory safety overhead when reading from that region.


<slice>
#foreachiso: `foreach` will automatically create an `iso` array if it's constructed with a bunch of `iso` elements.
</slice>


If you're curious, here's the `averageNeighbors` function, which takes its parameters in a similar way:

```
func averageNeighbors<r'>(rand &LCGRand, tiles &r'[][]bool, x int, y int) bool {
  num_neighbors = 0;
  num_white_neighbors = 0;
  foreach neighbor_x in range(x - 1, x + 1) {
    foreach neighbor_y in range(y - 1, y + 1) {
      if neighbor_x in 0..tiles.len() and neighbor_x in 0..tiles[0].len() {
        set num_neighbors += 1;
        set num_white_neighbors += if white { 1 } else { 0 };
      }
    }
  }
  result_is_white =
      if num_white_neighbors * 2 == num_neighbors {
        // Even number of white and black neighbors, so choose randomly.
        rand.next() mod 2 == 0
      } else {
        // true if most neighbors are white
        num_white_neighbors > num_neighbors / 2
      };
  return result_is_white;
}
```


# A Common Pattern: Option Swapping

Above, we showed how an `iso` in a variable can be passed to a function that read from it.


`iso`s are incredibly versatile when held in local variables, as we saw above.


Unless we use option swapping (explained below), an `iso` inside a struct can't be opened [# This is because an `iso` must never be opened twice at the same time, it must only be opened once. If we allowed opening a struct member `iso`, then it could indirectly be opened twice simultaneously.] unless:

 * The containing struct is destroyed first. [# This restriction can be combined with [Higher RAII](https://verdagon.dev/blog/higher-raii-7drl) to make some pretty interesting mechanisms. It's also conceptually similar to `GhostToken` in Rust.] [# Draft TODO: Can an iso be used like a ghosttoken, to pass around permission to open, say, a mutex? It would be zero cost.]
 * The containing struct is also `iso`.
 * The containing struct is in an immutable region.


But most of the time, we can just use a simple solution instead: wrap it in an `Option`!


In this example, a Spaceship has a private `Engine` that nobody outside needs to access.


We'd also like to make it faster to read this engine, so this is a perfect use case for an `iso`!


<<<<
When we want to access it, we swap a None into its place, and then put the `iso` into a local.

When we're done, we put the iso back into the Spaceship.

In the next section, we show a class that uses RAII to handle this for us automatically.
////
```
struct Spaceship {
  engine! Option<iso Engine>;
}
exported func blah(ship &Spaceship) {
  engine_iso =
      (set ship.engine = None()).expect();
  engine = engine_iso.imm;

  // Can read engine freely!

  set ship.engine = Some(engine_iso);
}
```
>>>>


# Cells


This kind of option swapping is so useful that we added a `Cell` type [# Not to be confused with Rust's `Cell`; it can be said that every field in Vale is implicitly a `Cell`. Rather, Vale's `Cell` is more like Rust's `RefCell`.] to the standard library to handle it for us, which uses RAII to ensure we put the iso back into the `Cell`.

It also has the benefit of being zero-cost for immutable regions. [# It does this with a certain feature called "region overloading", which specifies one function to use for immutable regions, and another for readwrite regions.] [# Draft TODO: We might actually want to add an assertion even when in immutable regions too, that someone else doesn't already have it opened. It wouldnt cause any unsafety if we don't, but it might be good to be consistent. At least in debug mode, perhaps.]


<<<<
Here, we have a `Cell<Engine>` instead of a `Option<iso Engine>`.


We call the `open` method to gain access to the contained `iso Engine`.


This returns an `iso CellGuard<Engine>`, which contains an `iso Engine` inside.


To immutably borrow the engine, we say `engine_handle.contents.imm`. [# We might add special syntax for this, something like `open ship.engine imm { ... }`. TBD!]
////
```
struct Spaceship {
  engine Cell<Engine>;
}
exported func blah(ship &Spaceship) {
  engine_handle = ship.engine.open();
  engine = engine_handle.contents.imm;

  // Can read engine freely!

  // engine_handle.drop() closes it.
}
```
>>>>

<slice/>


# Architectural Benefits

Besides their performance benefits, `iso`lates can also have an architectural benefit as well. When we don't want our private data to escape the containing struct, we can put it in an `iso` and the compiler will tell us when a reference to it accidentally gets out.


This helps us reason about our data little easier, and often means we don't have to make defensive copies.


We can even use `iso`s to assist and enforce [unidirectional data flow](https://www.geeksforgeeks.org/unidirectional-data-flow/), the same technique that makes it so functional programming and Rust programs tend to work on the first try more often.


# Conclusion


As we saw, `iso`lates can be surprisingly powerful for optimization, and using them well can make a program much faster.


Part 3 shows how we can enable that using *one-way isolation*. Most structs' private data can actually be expressed very cleanly with one-way isolation, `pure` functions also use it under the hood.


Part 4 also shows how one-way isolation can make certain patterns (iterating collections, calculating determinants, etc.) and entire architectures (like entity-component-system) zero-cost. [# Together, `iso`lates, `pure` functions, and one-way isolation combine to form something that looks suspiciously like an entire new programming paradigm... whether that's true remains to be seen!]



*That's all for now!* We hope you enjoyed this article. Stay tuned for the next article, which shows how `iso`lated sub-regions work.


If you're impressed with our [track record](https://vale.dev/roadmap#recent-additions) and believe in the [direction we're heading](https://vale.dev/roadmap), please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>

With your support, we can bring regions to programmers worldwide.


See you next time!

- Evan Ovadia



[#deepiso]
[#mostlyzero]

<slice new-color="afterword">

#deepiso: `iso` can be applied to any pure function call. It will enforce that all arguments we pass in are also `iso`. Here, the compiler is automatically applying `iso` to the `Engine(...)` and `Radar(...)` calls.

Draft TODO: See if there are any bad interactions with universal references. Last resort, `iso` calls might need a new implicit region instance with a new generation.



#mostlyzero: Accessing any owned data, like the `.engine` and `.fuel` in this example, will be zero cost.

Accessing any non-owning references, such as if `Spaceship` had a `fleet &Fleet`, might incur a "generation pre-check" as it reads it.
</slice>


# Vale's Vision

Vale aims to bring a new way of programming into the world that offers *speed*, *safety*, and *ease of use.*


*The world needs something like this!* Currently, most programming language work is in:

 * High-overhead languages involving reference counting and tracing garbage collection.
 * Complex languages (Ada/Spark, Coq, Rust, Haskell, etc.) which impose higher complexity burden and mental overhead on the programmer.

These are useful, but there is a *vast field of possibilities* in between, waiting to be explored!


Our aim is to explore that space, discover what it has to offer, and make *speed and safety easier than ever before.*


In this quest, we've discovered and implemented a lot of new techniques:

 * [Generational Memory](/blog/generational-references), for a language to ensure an object still exists at the time of dereferencing.
 * [Higher RAII](/blog/raii-next-steps), a form of linear typing that enables destructors with parameters and returns.
 * [Fearless FFI](/blog/fearless-ffi), which allows us to call into C without risk of accidentally corrupting Vale objects.
 * [Perfect Replayability](/blog/perfect-replayability-prototyped), to record all inputs and replay execution, and completely solve heisenbugs and race bugs.


These techniques have also opened up some new emergent possibilities, which we hope to implement:

 * [Region Borrow Checking](/blog/zero-cost-refs-regions), which adds mutable aliasing support to a Rust-like borrow checker.
 * [Hybrid-Generational Memory](/blog/hybrid-generational-memory), which ensures that nobody destroys an object too early, for better optimizations.
 * [Seamless concurrency](https://verdagon.dev/blog/seamless-fearless-structured-concurrency), the ability to launch multiple threads that can access any pre-existing data without data races, without the need for refactoring the code or the data.
 * Object pools and bump-allocators that are memory-safe and decoupled, so no refactoring needed.


We also gain a lot of inspiration from other languages, and are finding new ways to combine their techniques:

 * We can mix an `unsafe` block with Fearless FFI to make a much safer systems programming language!
 * We can mix Erlang's isolation benefits with functional reactive programming to make much more resilient programs!
 * We can mix region borrow checking with Pony's `iso` to support shared mutability.

...plus a lot more interesting ideas to explore!


The Vale programming language is a novel combination of ideas from the research world and original innovations. Our goal is to publish our techniques, even the ones that couldn't fit in Vale, so that the world as a whole can benefit from our work here, not just those who use Vale.


Our medium-term goals:

 * Finish the Region Borrow Checker, to show the world that shared mutability can work with borrow checking!
 * Prototype Hybrid-Generational Memory in Vale, to see how fast and easy we can make single ownership.
 * Publish the Language Simplicity Manifesto, a collection of principles to keep programming languages' learning curves down.
 * Publish the Memory Safety Grimoire, a collection of "memory safety building blocks" that languages can potentially use to make new memory models, just like Vale combined generational references and scope tethering.


We aim to publish articles biweekly on all of these topics, and create and inspire the next generation of fast, safe, and easy programming languages.


If you want to support our work, please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

With enough sponsorship, we can:

 * Work on this full-time.
 * Turn the Vale Language Project into a 501(c)(3) non-profit organization.
 * Make Vale into a production-ready language, and push it into the mainstream!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>
