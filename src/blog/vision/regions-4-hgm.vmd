---
title: Zero-Cost Memory Safety with Vale Regions, Part 4: Hybrid-Generational Memory
subtitle: Watch how we split our memory into regions, for more performance!
author: Evan Ovadia
date: Draft
realm: blog
path: blog/zero-cost-memory-safety-regions-part-1-pure-functions
layout: annotated
namespace: c-blog m-annotated
sponsor: us
---



lets come up with a better name.

LifeCell likely not good. refcell has a bad name.






arr’ own e’

means that arr' objects can own e' objects inline.

more likely. arr' owns E, like a coord. that way if the caller supplies a borrow then the restrictions can be disregarded

can use this to replace HGM. array will be an iso<owns E> or something.

struct List<E> where self' owns E {
  array iso []E;
}

func each<E, F>(list &List<E>, f F)
where self' owns E, func(F, &E)void {
  rguard = list.array.lock_read();
  // rguard is reading the iso immly
  each(rguard.value, f);
}

func each<arr' ro, E, F>(a arr'&[]E, f F)
where arr' owns E, func(F, &E)void {
  ...
}

inside that last each, we can give out &E just fine, even though the array is readonly. nobody can modify the array itself with just a borrow reference to an element.







we'll still need some way to hold onto a lock on the object and use it for free derefs. thats basically the spirit of hgm.

we'll need it for iterators specifically. so we still do have live refs



perhaps begin can take a region, and return a thing tied to that region, so we can know the lock wont outlive that region

but that wont really work without an RC.. hmm

live on a borrow will keep it alive
live on an own struct will apply to the borrows in the struct

we can do imm reading, or rw reading thatll keep the thing shallowly alive like old hgm perhaps?

maybe we can just do imm reading for now.





struct HashMapIter<z', K, V> {
  arr &z'[]?(K, V);
}

first grab the array:
arr imm&[]?(K, V) = lock(myMap.arr);

then make the iter:
it = HashMapIter(arr);

itll grab arr's region, know its immutable, and itll be good.

the tricky part is combining those two steps...

imm is kinda weird. must be bound to a local currently. unless we switch to true RC.

hard cuz we literally need two locals for this. one for the lock, one for the iter.

rusts refcell likely faces this trouble too...

foreach loops actually have a local for their iterable, you know. we could have it call lock for it perhaps? or user can do it explicitly, that kind of works.